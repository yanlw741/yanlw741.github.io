{"meta":{"title":"yanlwsometing","subtitle":"","description":"穷则独善其身，达则兼济天下！","author":"yanlw","url":"https://yanlwsometing.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404","date":"2023-05-13T07:43:14.000Z","updated":"2023-05-13T07:46:43.369Z","comments":true,"path":"404/index.html","permalink":"https://yanlwsometing.gitee.io/blog/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-05-13T07:33:48.000Z","updated":"2023-05-13T07:36:49.846Z","comments":true,"path":"categories/index.html","permalink":"https://yanlwsometing.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"images","date":"2023-05-13T10:36:02.000Z","updated":"2023-05-13T10:36:02.347Z","comments":true,"path":"images/index.html","permalink":"https://yanlwsometing.gitee.io/blog/images/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-05-13T07:33:11.000Z","updated":"2023-05-13T07:36:55.570Z","comments":true,"path":"tags/index.html","permalink":"https://yanlwsometing.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣刷题记录","slug":"力扣刷题记录","date":"2024-01-29T10:02:44.000Z","updated":"2024-01-29T10:08:16.945Z","comments":true,"path":"2024/01/29/力扣刷题记录/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2024/01/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"二分查找例题. https://leetcode.cn/problems/binary-search/","categories":[],"tags":[]},{"title":"C++","slug":"C++","date":"2023-12-22T08:20:40.000Z","updated":"2024-01-22T08:27:53.405Z","comments":true,"path":"2023/12/22/C++/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/12/22/C++/","excerpt":"","text":"C++[TOC] C++基础1. std:: 是什么std:: 是 C++ 标准库（Standard Library）的命名空间（namespace）前缀。 标准库中的各种类、函数和对象都被组织在 std 命名空间内，以避免命名冲突和提供一种更好的封装机制。使用 std:: 前缀是为了指明所使用的标准库中的元素，例如： 123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; return 0;&#125; 如果在程序开头使用了 using namespace std;，则可以省略 std:: 前缀，但在大型项目或者有可能发生命名冲突的情况下，最好还是使用 std:: 前缀，以确保代码的清晰性和可维护性。 2. 为什么c++的效率更高 直接内存访问： C++ 允许直接操作内存，包括指针和数组的使用。这使得程序员能够更精细地控制内存的分配和释放，以及更有效地进行数据操作。 静态类型系统： C++ 是一种静态类型语言，编译器在编译时检查类型，并在运行时不需要进行类型检查。这消除了一些运行时开销，提高了程序的性能。 高度优化的编译器： C++ 编译器通常能够进行更高度的优化，生成更有效率的机器代码。编译器优化技术包括内联函数、循环展开、死代码删除等，有助于减小程序的运行时间和内存占用。 近硬件级别的抽象： C++ 允许直接访问硬件，并提供近似硬件级别的抽象，使得程序员可以更好地优化代码以适应底层硬件特性。 C++特性 1. 类C++是面向对象的语言，类是面向对象编程（Object-Oriented Programming，OOP）的基本概念之一。类是一种用户定义的数据类型，用于封装数据和相关的操作，它允许将数据和函数（成员函数）组织在一个逻辑单元中，从而更好地模拟现实世界中的对象和其行为。 a. 构造函数i. 默认构造函数C++会提供一个默认构造函数。默认构造函数不接受任何参数，它的主要作用是初始化对象的成员变量 1234567class MyClass &#123;public: // 默认构造函数 MyClass() &#123; // 初始化操作 &#125;&#125;; 在某些情况下，你可能需要声明默认构造函数，但又不希望自己实现它。这时，你可以使用= default语法来告诉编译器使用默认行为。 1234567class MyClass &#123;public: // 声明默认构造函数 MyClass() = default; // 其他成员函数和数据成员...&#125;; ii. 委托构造函数在一个构造函数中调用另一个构造函数，可以减少代码的重复，提高代码的可维护性。 1234567891011class MyClass &#123;public: // 委托构造函数 MyClass() : MyClass(0) &#123; // 委托给带参数的构造函数，传递默认值 &#125; MyClass(int initialValue) &#123; // 初始化操作 &#125;&#125;; iii. 初始化列表：12Counter(int value) : value_(value) &#123;&#125; 这个构造函数的初始化列表部分是 : value_(value)。这表示在构造函数开始执行之前，将 value_ 成员变量初始化为传入构造函数的 value 值。 从功能上，和传统写法效果相同，但是存在差异： 性能优势： 使用初始化列表可以避免先调用默认构造函数初始化成员变量，然后再在构造函数体内赋值的操作，从而提高性能。 成员变量初始化顺序： 初始化列表允许你指定成员变量的初始化顺序。在构造函数体内，成员变量的初始化顺序是按照它们在类中声明的顺序执行的，而在初始化列表中，你可以按照自己的需要指定顺序。 常量成员变量和引用成员变量： 对于常量成员变量和引用成员变量，它们只能在初始化列表中进行初始化，因为它们不能在构造函数体内被重新赋值。 iiii. 继承构造函数继承构造函数是C++11引入的一项特性，它允许派生类继承基类的构造函数。这样，派生类可以使用基类的构造函数，而无需重新实现相同的构造逻辑。这提高了代码的重用性和简洁性。 1234567891011121314class Base &#123;public: Base(int x, double y) &#123; // 基类构造函数的实现 &#125;&#125;;class Derived : public Base &#123;public: // 继承基类的构造函数 using Base::Base; // 派生类其他成员函数和数据成员...&#125;; b. 拷贝构造函数拷贝构造函数用于在创建一个对象时，使用同一类的另一个对象的值来初始化新对象。通常接受一个同类型的对象作为参数。 1234567class MyClass &#123;public: // 复制构造函数 MyClass(const MyClass&amp; other) &#123; // 使用 other 的值来初始化新对象 &#125;&#125;; 注意：拷贝构造函数和拷贝赋值是在 C++ 中用于处理对象拷贝的两个不同的概念，拷贝构造函数通常用于对象的初始化，而拷贝赋值操作符用于已经存在对象的赋值。 12345678910111213class MyClass &#123;public: // 拷贝赋值操作符 MyClass&amp; operator=(const MyClass&amp; other) &#123; if (this != &amp;other) &#123; // 防止自赋值 // 释放已有资源，如果有的话 // 进行赋值操作 // 例如：将 other 的成员变量的值复制给当前对象的相应成员变量 &#125; return *this; // 返回引用以支持连续赋值 &#125;&#125;; c. 移动构造函数移动构造函数是C++11引入的一项特性，用于在对象之间高效地转移资源的所有权而不进行深层的数据复制。C++中常用的vector，list，map都可以移动构造和移动赋值。 传统的拷贝构造函数在创建一个新对象时，需要复制另一个对象的所有成员变量的值，包括可能的动态分配的资源。而移动构造函数则允许在不进行实际数据复制的情况下，将另一个对象的资源直接移交给新对象，从而避免了不必要的开销。 12MyClass obj1; // 创建对象MyClass obj2 = std::move(obj1); // 使用移动构造函数 移动构造函数通过右值引用（Rvalue Reference）来实现，其语法形式为： 1234567class MyClass &#123;public: // 移动构造函数 MyClass(MyClass&amp;&amp; other) noexcept &#123; // 在这里进行资源的转移，避免数据复制 &#125;&#125;; 右值引用是什么? 右值引用是 C++11 引入的一种引用类型，用于标识可以被移动的对象。 在 C++ 中，表达式有两种值类别：左值（lvalue）和右值（rvalue）， 左值（lvalue）： 表示一个具名的内存位置，可以通过其地址访问。通常，左值是可以取地址的表达式，如变量或对象的成员。左值具有持久性，因为它们在程序中存在的一段时间。 右值（rvalue）： 表示一个临时的、一次性的值，通常没有具名的内存位置。右值是表达式的结果，但不能通过地址访问。右值通常是临时创建的、即将被销毁的值，如字面量、临时对象等。右值引用使用 &amp;&amp; 符号声明，用于绑定到右值 1234567891011121314#include &lt;iostream&gt;int main() &#123; int x = 42; // x 是左值 int&amp; lref = x; // lref 是左值引用，引用 x int&amp;&amp; rref = 42; // rref 是右值引用，引用字面量 42 std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl; std::cout &lt;&lt; &quot;lref: &quot; &lt;&lt; lref &lt;&lt; std::endl; std::cout &lt;&lt; &quot;rref: &quot; &lt;&lt; rref &lt;&lt; std::endl; return 0;&#125; 注意：左值是内存位置本身，指针是存储地址的变量，总体而言，左值是一个更广泛的概念，它包括了指针。指针是一种用于处理内存地址的特殊类型的左值 eg. 实现一个移动构造函数，用于在对象之间高效地转移字符串的所有权 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; // 用于字符串操作class String &#123;public: // 默认构造函数 String() : data(nullptr) &#123;&#125; // 析构函数 ~String() &#123; delete[] data; &#125; // 拷贝构造函数 String(const String&amp; other) : data(new char[strlen(other.data) + 1]) &#123; std::cout &lt;&lt; &quot;Copy constructor called.&quot; &lt;&lt; std::endl; strcpy(data, other.data); &#125; // 移动构造函数 String(String&amp;&amp; other) noexcept : data(other.data) &#123; std::cout &lt;&lt; &quot;Move constructor called.&quot; &lt;&lt; std::endl; other.data = nullptr; // 转移资源所有权 &#125; // 打印字符串 void print() const &#123; std::cout &lt;&lt; (data ? data : &quot;Empty String&quot;) &lt;&lt; std::endl; &#125;private: char* data;&#125;;int main() &#123; String original(&quot;Hello, World!&quot;); // 使用拷贝构造函数 String copy(original); copy.print(); // 使用移动构造函数 String moved = std::move(original); moved.print(); original.print(); // 注意：original 的资源已经被移动，处于空状态 return 0;&#125; 2. 继承继承分为多重继承和单继承，在实际使用时多重继承会有菱形继承的问题，需要处理积累成员的名字冲突问题，继承树复杂。建议在实际使用时，多重继承，除了一个实际继承，另外的使用接口继承。 访问权限（public、protected、private）影响的是派生类对基类成员的访问权限，而不是派生类对象的访问权限。 a. 虚函数在基类中将函数声明为virtual是虚函数，如果加上&#x3D;0则是纯虚函数。在子类中通过加上override，可以检测基类中是否声明为virtual。编译器为包含虚函数的类创建一张虚表(vtable).类的每个对象内部有一个指向虚表的指针 (yptr)，根据虚指针可以找到绑定的虚函数。 3. 封装封装指的是将数据（成员变量）和操作数据的方法（成员函数）捆绑在一起，形成一个逻辑上的单元。封装通过将数据和操作数据的方法放置在一个单一的实体内部，从而隐藏了数据的具体实现细节，并提供了对外界的接口来访问和操作数据。 就好像一头奶牛，想喝牛奶的话不能直接拿（物理层面），要通过挤奶（成员函数）获得牛奶（成员变量） a. 成员函数类的成员函数是定义在类内部的函数，它们用于执行特定的操作或提供特定的服务。成员函数通常访问类的成员变量，并定义在类的声明中或类的定义体内。 成员函数的定义： 1234567891011121314// 类的声明class MyClass &#123;public: // 成员函数原型 void myFunction(int x); // 其他成员声明...&#125;;// 类的定义体void MyClass::myFunction(int x) &#123; // 成员函数的实现 // 可以访问类的成员变量和其他成员函数&#125; 成员函数的访问权限： 成员函数的访问权限（public、private、protected）决定了该函数是否可以被类的外部访问。public 成员函数可以在类的外部调用，而 private 成员函数只能在类的内部调用。 静态成员函数： 静态成员函数属于类而不是类的实例，可以在没有类实例的情况下被调用。静态成员函数不能直接访问非静态成员变量，因为它们没有隐式的 this 指针。 12345678910class MyClass &#123;public: static void staticFunction() &#123; // 可以在静态成员函数中访问静态成员变量 std::cout &lt;&lt; &quot;Static function called.&quot; &lt;&lt; std::endl; &#125;private: static int staticVariable;&#125;; b. 运算符重载operator 是 C++ 中的关键字，用于定义类的成员函数，这些成员函数实现了类对象与运算符之间的操作。运算符重载的一般形式为： 123return_type operator@ (parameters) &#123; // 实现与运算符@相关的操作&#125; 不同的运算符有不同的参数个数: 一元运算符：++，--，一元减号- 二元运算符：+，-， * 关系运算符：==，!=，&gt; 赋值运算符：= 函数调用运算符：() 以下是一个简单的运算符重载的示例，演示了自定义类中重载加法运算符 +： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;class Complex &#123;public: double real; double imag; // 构造函数 Complex(double r, double i) : real(r), imag(i) &#123;&#125; // 重载加法运算符+ Complex operator+ (const Complex&amp; other) const &#123; return Complex(real + other.real, imag + other.imag); &#125;&#125;;int main() &#123; Complex c1(1.0, 2.5); Complex c2(2.0, 1.5); // 使用重载的加法运算符+ Complex result = c1 + c2; // 输出结果 std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result.real &lt;&lt; &quot; + &quot; &lt;&lt; result.imag &lt;&lt; &quot;i&quot; &lt;&lt; std::endl; return 0;&#125; 函数对象Function Object, 也称为仿函数（Functor），它是一个类或结构体的实例，其实例可以像函数一样被调用。函数对象通常是通过在类中定义operator()来实现的。 以下是一个简单的函数对象的示例： 12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// 函数对象类，用于逆序排序class MyComparator &#123;public: bool operator()(int a, int b) const &#123; return a &gt; b; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; numbers = &#123;5, 2, 8, 3, 1, 7&#125;; // 使用函数对象进行逆序排序 std::sort(numbers.begin(), numbers.end(), MyComparator()); // 输出排序后的结果 for (int num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 4. 自动类型推导 C++11 引入的auto 和 decltype 是用于类型推导的关键字，它们分别用于不同的情境。 auto decltype 静态的，在编译时进推到 动态的，在运行时推导 忽略顶层const、引用等修饰符，只推导类型本身 保留表达式的类型修饰符 推导数组会退化为指针类型 可以正确推导数组类型 不可以用于函数返回值类型 不可以用于函数返回值类型 1234567891011121314const int x = 1;auto a = x; // a 是 int decltype(x) b = 1; // b 是 const intint arr[5];auto c = arr; // c 是 int*decltype(arr) d; // d 是 int[5]struct A &#123; int&amp; foo();&#125; a;auto e = a.foo(); // 错误decltype(a.foo()) f; // f 是 int&amp; 5. constexprconstexpr 是 C++11 引入的关键字，用于声明一个常量表达式。使用 constexpr 关键字可以告诉编译器，某个变量或函数可以在编译时求值，相较于宏更加的安全。 123456789101112131415161718192021// 常量函数constexpr int factorial(int n) &#123; return (n &lt;= 1) ? 1 : n * factorial(n - 1);&#125;// 常量表达式constexpr int num = 5;// 常量变量constexpr int fact_num = factorial(num); int main() &#123; // 在编译时求值 int array[fact_num]; // 在运行时求值 std::cout&lt;&lt; factorial(5) &lt;&lt; endl; return 0;&#125; 6. 智能指针智能指针是C++中用于管理动态分配内存的一种机制，它们提供了对动态分配内存的自动管理，有助于防止内存泄漏和提高代码的安全性。 C++标准库提供了三种智能指针：std::unique_ptr 、 std::shared_ptr和std::wake_ptr。 std::unique_ptr： 表示独占所有权的智能指针。独占型指针不允许拷贝，只能移动，可以通过reset释放和重置管理的对象。 std::shared_ptr： 表示共享所有权的智能指针。共享型指针可以拷贝，通过引用计数方式管理对象，当引用计数为零时释放。 std::weak_ptr： 是为了解决 std::shared_ptr 的循环引用问题而引入的。弱引用不管理对象，与共享型配合，避免循环引用。 现代 C++：一文读懂智能指针 - 知乎 (zhihu.com) 7. Lambda函数Lambda 表达式是 C++11 引入的一种匿名函数的方式，允许在代码中内联定义函数，即用即写。Lambda 表达式的语法类似于函数，但它可以在声明的地方定义，无需额外的函数声明。 1234567891011121314151617181920212223#include &lt;iostream&gt;int main() &#123; // Lambda 表达式，不捕获任何变量 auto func1 = []() &#123; std::cout &lt;&lt; &quot;Hello, Lambda!&quot; &lt;&lt; std::endl; &#125;; // 调用 Lambda 表达式 func1(); // Lambda 表达式，捕获外部变量 int x = 10; auto func2 = [x]() &#123; std::cout &lt;&lt; &quot;Captured variable: &quot; &lt;&lt; x &lt;&lt; std::endl; &#125;; // 调用 Lambda 表达式 func2(); return 0;&#125; Lambda 表达式的基本语法如下： 123[capture](parameters) -&gt; return_type &#123; // 函数体&#125; capture：捕获列表，用于捕获外部变量。 parameters：参数列表，类似于函数的参数。 return_type：返回类型，指定 Lambda 表达式的返回类型。 &#123;&#125;：Lambda 表达式的函数体。 8. 可变参数模板可变参数模板是 C++11 引入的一种模板特性，允许定义接受任意数量参数的模板。 可变参数模板使用了模板参数包（template parameter pack）和展开表达式（parameter pack expansion）。 12345678910111213141516171819#include &lt;iostream&gt;// 递归终止条件，即参数包为空时调用执行void printArgs() &#123; std::cout &lt;&lt; std::endl;&#125;// 可变参数模板template &lt;typename T, typename... Args&gt;void printArgs(T first, Args... args) &#123; std::cout &lt;&lt; first &lt;&lt; &quot; &quot;; printArgs(args...); // 递归调用，展开参数包&#125;int main() &#123; printArgs(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); return 0;&#125; 在这个例子中，printArgs 是一个可变参数模板函数。它接受一个任意类型的参数 first，并且通过递归调用自己，展开参数包 Args...。当参数包为空时，递归终止，输出一个换行符。 C++14 引入了更简洁的展开语法，使得可变参数模板的使用更加方便。 12345678910111213#include &lt;iostream&gt;// 可变参数模板（C++14）template &lt;typename... Args&gt;void printArgs(Args... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; // 使用fold表达式展开参数包&#125;int main() &#123; printArgs(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); return 0;&#125; 可变数目的参数被称为参数包，存在两种参数包：模板参数包，表示0个或多个模板参数；函数参数包，表示0个或者多个函数参数。 1234567891011// Template Parameter Packtemplate &lt;typename... Ts&gt;class MyTemplate &#123; // 使用 Ts... 来定义模板参数包&#125;;// Function Parameter Packtemplate &lt;typename... Args&gt;void myFunction(Args... args) &#123; // 使用 Args... 来定义函数参数包&#125; 下面是一些例子，演示了可变参数模板的不同应用场景。 计算参数的总和 123456789101112131415161718#include &lt;iostream&gt;// 递归终止条件int sumArgs() &#123; return 0;&#125;// 可变参数模板，递归调用自己来计算参数的总和template &lt;typename T, typename... Args&gt;T sumArgs(T first, Args... args) &#123; return first + sumArgs(args...);&#125;int main() &#123; std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sumArgs(1, 2, 3, 4, 5) &lt;&lt; std::endl; return 0;&#125; 定义通用的容器类 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;template &lt;typename... Ts&gt;class MyContainer &#123;public: MyContainer(Ts... values) : data(&#123;values...&#125;) &#123;&#125; void print() const &#123; for (const auto&amp; value : data) &#123; std::cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125;private: std::vector&lt;int&gt; data;&#125;;int main() &#123; MyContainer&lt;int, double, std::string&gt; container(42, 3.14, &quot;Hello&quot;); container.print(); return 0;&#125; 9. Fold表达式折叠表达式（Fold Expression）是 C++17 引入的一项特性，用于简化对参数包进行操作的语法。折叠表达式允许在一个表达式中展开参数包，使得编写对变参进行操作的代码更加简洁。 1( expression op ... ) 其中： expression 是用于对参数包进行操作的表达式。 op 是折叠的操作符，可以是二元运算符或者逗号运算符。 有两种折叠表达式的形式： 1. 左折叠表达式（Left Fold Expression）(... op args) eg. 左折叠表达式求和 12345678910template &lt;typename... Args&gt;auto sum(Args... args) &#123; return (args + ...);&#125;int main() &#123; int result = sum(1, 2, 3, 4, 5); // 等价于：((1 + 2) + 3) + 4 + 5 return 0;&#125; 2. 右折叠表达式（Right Fold Expression）(args op ...) eg. 右折叠表达式求和 1234567891011template &lt;typename... Args&gt;auto sum(Args... args) &#123; return (... + args);&#125;int main() &#123; int result = sum(1, 2, 3, 4, 5); // 等价于：1 + (2 + (3 + (4 + 5))) return 0;&#125; 3. 逗号运算符逗号运算符在 C++ 中是一个二元运算符，用于连接两个表达式，并按照从左到右的顺序求值。逗号运算符的基本形式是 expr1, expr2，它首先求值 expr1，然后求值 expr2，并返回 expr2 的值。 1234567891011template &lt;typename... Args&gt;void print(Args... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;&#125;int main() &#123; print(&quot;Hello&quot;, &quot;, &quot;, &quot;World&quot;); // 等价于：(std::cout &lt;&lt; &quot;Hello&quot;) &lt;&lt; &quot;, &quot; &lt;&lt; &quot;World&quot; &lt;&lt; std::endl; return 0;&#125; C++线程管理多线程编程是指在一个程序中同时执行多个线程，每个线程都是程序中独立的执行单元。多线程的目的是提高程序的性能和资源利用率，特别是在多核处理器上。以下是多线程编程的一些基本概念： 进程：一个进程（Process）通常代表一个正在运行的程序的实例。例如打开一个软件，软件可能需要启动一个或多个进程来执行不同的任务：主进程、GUI 进程、后台进程（更新检查、定时任务） 线程：线程是操作系统能够进行运算调度的最小单位 进程状态： 线程状态：synchronized是Java中的关键字，synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区。 Blocked 与 Waiting 的区别 Blocked 是在等待其他线程释放 monitor 锁 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()&#x2F;notifyAll() 。 Timed Waiting 状态，它与 Waiting 状态非常相似，其中的区别只在于是否有时间的限制。如果超时时间到了那么就会系统自动直接拿到锁，或者当 join 的线程执行结束&#x2F;调用了LockSupport.unpark()&#x2F;被中断等情况都会直接进入 Runnable 状态，而不会经历 Blocked 状态。 互斥（Mutual Exclusion）： 互斥是一种同步机制，用于防止多个线程同时访问共享资源。互斥锁（Mutex）是最常用的实现互斥的手段，它确保在任何时刻只有一个线程可以进入被互斥保护的代码段。 临界区（Critical Section）： 临界区是一段代码，同一时刻只允许一个线程进入执行。在临界区内的代码可能访问共享资源，因此需要使用互斥手段确保同一时刻只有一个线程执行该代码段。 条件变量（Condition Variable）： 条件变量是一种用于线程之间通信的同步机制。它通常与互斥锁一起使用，允许线程等待某个条件的发生。当条件发生时，唤醒等待的线程继续执行。 1. std::thead2. std::this.thead3. std::future4. std::promise5. std::async6. std::mutex std::shared_mutex7. std::condition_variable8. std::latch9. std::barrier10. std::couting_semaphore11. std::atomic","categories":[],"tags":[]},{"title":"TCL","slug":"TCL","date":"2023-12-16T12:51:42.000Z","updated":"2023-12-16T15:04:01.203Z","comments":true,"path":"2023/12/16/TCL/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/12/16/TCL/","excerpt":"","text":"TCL概念TCL， 重要的EDA脚本语言，用于控制EDA工 具 使用方法Linux环境下，输入tclsh。Windows系统下，安装active tcl并双击wish.exe 1. 置换TCL解释器运用规则把命令分成一个个独立的单词，同时进行必要的置换。TCL置换分为以下三类：变量置换，命令置换，反斜杠置换 a. 变量置换 b. 命令置换类似于shell的$() c. 反斜杠置换\\t 表示TAB，\\n表示换行符 d. 其他 “双引号中会置换$、[]” &#123;花括号里会变成普通字符&#125; # 注释 2. 变量 定义 取值 变量 set 变量名 变量值 $变量名 数组 set 数组名(元素名) 值 $数组名(元素名) 列表 set 列表名{元素1 元素2 元素3……} $列表名 1234567891011set a 2 # 2puts $&#123;a&#125;_1 # 2_1set cell_1(ref_name) &quot;bufx2&quot; # bufx2set cell_1(full_name) &quot;top/cell_1&quot; # top/cell_1puts $cell_1(ref_name) # bufx2# 使用array指令获取数组信息array size cell_1 # 2array names cell_1 # ref_name full_name 3. 运算 4. 控制流a. if b. foreach c. breakd. continuee. while f. for 5. 过程函数 6. 全局变量 7. 正则表达式 8. 文本处理 格式 功能 open open 文件 打开方式(r&#x2F;w) 打开文件 gets get fileID 变量名 gets读fileID标识的文件的下一行，并把该行赋给变量， 并返回该行的字符数(文件尾返回-1) close· close fileID 关闭文件","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"TCL","slug":"TCL","permalink":"https://yanlwsometing.gitee.io/blog/tags/TCL/"}]},{"title":"电路分析基础","slug":"电路分析基础","date":"2023-12-12T06:33:20.000Z","updated":"2024-05-05T05:44:52.832Z","comments":true,"path":"2023/12/12/电路分析基础/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/12/12/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/","excerpt":"电路分析基础一、电路模型 电路： 由电器件相互连接所构成的电流通路 理想元件模型","text":"电路分析基础一、电路模型 电路： 由电器件相互连接所构成的电流通路 理想元件模型 集总参数电路（几何尺寸远小于波长），分布参数电路；线性电路（线性代数或者微积分方程），非线性电路；时不变电路（常系数代数或微积分方程），时变电路；动态电路，电阻电路 电压变量 电功率变量 KCL（基尔霍夫电流定律）： 对于任一集中参数电路中的任一节点，在任一瞬间，流入某一结点电流的代数和恒等于零 描述了连接在同一节点上的各支路电流之间的关系 KVL（基尔霍夫电压定律）：对于集中参数电路，在任一时刻，沿任一回路巡行一周，各支路电压降的代数和为零 二、电路元件 独立源（独立电压源，独立电流源） 受控源 电路的等效 电阻等效定义： 电路等效定义： (1) 串并联等效电阻串联等效公式： R(eq) &#x3D; R0 + R1…… + Rn 串联电阻的分压公式 ： Uk &#x3D; Rk * i &#x3D; Rk &#x2F; Req* U 并联电导等效公式： Geq &#x3D; G0 + G1…… + Gn 并联电阻分流公式：i_k &#x3D; Gk * u &#x3D; Gk &#x2F; Geq * i (2) Δ形Y形连接等效 (3) 含受控源等效无独立源 (4) 实际电源等效电源转唤等效 (5) 电源等效转移电压源转移等效 e.g. 电流源转移等效 e.g. 电桥平衡定义： 特性：等电位点连接任意阻值的电阻，不影响外电路的支路量 三、求解电路KCL独立方程 KVL独立方程 1. 2b法 &amp; 支路法2b法定义：以b个支路电压和b个支路电流为未知变量列写未知变量并求解方程的方法 e.g. 支路法：以支路电流（或电压）为未知变量列出方程 e.g. 2. 回路法以独立回路电流为未知变量列出方程并求解电路的方法。若选平面电路的网孔作为独立回路，有常称为网孔法 回路电流与支路电流关系 回路电流方程： 回路法列写方程规律总结 3. 节点法以节点电压为未知量列出并求解方程的方法 节点电压与支路电压的关系 节点电压列写方程 节点法列写方程规律总结 四、线性性质线性电路是指线性元件、线性受控源和独立源组成的电路。定理是线性电路的线性性质的体现。 1. 齐次定理内容：对于具有唯一解的线性电路，当只有一个激励源（独立电压源或独立电流源）作用时，其响应（电路任意处的电压或电流）与激励成正比 e.g. 2. 叠加定理内容:对于具有唯一解的线性电路，多个激励源共同作用时引起的响应(电路中各处的电流、电压)等于各个激励源单独作用时(其它激励源置零)所引起的响应之和。 e.g. 叠加与齐次共同作用 3. 替代定理内容:在任意的具有唯一解的线性或非线性电路中，若某一支路的电压u&#x2F;电流i已知，无论该支路是由什么元件组成，那么该支路可以用一个理想电压源、或用一个理想电流源来替代。替代后电路中其它各处的电流和电压均保持原来的值。 e.g. 4. 戴维南定理等效电源定理包括：戴维南定理，诺顿定理 作用：将一个含源网络等效成电阻和电压源的等效关系 内容：对于任一线性二端含源网络N，从外部来看，可以用一个电压源和电阻的串联组合来等效。 戴维南开路电压 戴维南等效电阻 不含受控源的：串并联 含受控源的： （1）外加电源法 （根据KCL，u&#x3D;3i, R0 &#x3D; 3） （2）开路短路法 （3）伏安关系法 （与外加电源法区分，此处没有将独立源置零） 5. 诺顿定理6. 最大功率传输定理 功率传输效率 e.g. 7. 特勒根定理特勒根定理一 特勒根定理二 8. 互易定理对于一个仅含线性电阻的二端电路N，在只有一个激励源的情况下，当激励与响应互换位置时，同一激励所产生的响应相同。 节点 ：电势 线：电流 元件：电阻 + 自定义属性 五、电路的动态分析1. 电容“Capacitor，装载电荷的容器”， a. 电容的伏安关系微分形式 积分形式 电容器的电荷量 𝑞(𝑡)q(t) 取决于电压 𝑣(𝑡)v(t) 的历史积分，这意味着电容器上的电荷量不仅取决于当前的电压，还取决于过去电压的变化。这就是电容器的“记忆”特性，它能够“记住”过去的电压变化。 即使电压停止变化，电容器上的电荷仍然保持不变，除非有外部电路允许电荷流出或流入电容器。这表明电容器能够存储电荷，即存储能量，这也是记忆元件的一个特性。 当电容器两端的电压突然发生变化时，电流 𝑖(𝑡)i(t) 会瞬间响应，但电荷量 𝑞(𝑡)q(t) 不会立即改变，因为它需要时间积累。这进一步说明了电容器对电压历史的记忆能力。 即它能够根据电压的变化历史存储和释放电荷 b. 电容元件瞬时功率 储能 c. 串联与并联 串联电容相当于减小了电容的板面积，而并联电容相当于增加了电容的板面积 2. 电感把电能转化为磁能而存储起来的元件，具有阻止交流电通过而让直流电通过的特性 a.电感的伏安关系微分形式 积分形式 b.电感元件瞬时功率 储能 c. 串联与并联 3. 动态电路方程建立方程的依据：元件的VAR，KCL和KVL 步骤： ​ (1)、根据电路结构列写电路的KCL或KVL方程，并列写各元件的伏安关系;​ (2)、在以上方程中消去中间变量，得到所需电路变量满足的微分方程。（此处特指线性常系数微分方程） 动态电路中包含独立动态元件的个数即是该电路微分方程的阶次数 对于较复杂的动态电路，常用拉普拉斯变换进行分析。","categories":[{"name":"IC基础","slug":"IC基础","permalink":"https://yanlwsometing.gitee.io/blog/categories/IC%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"","slug":"Altium Designer","date":"2023-11-27T03:00:26.545Z","updated":"2023-12-12T06:38:20.469Z","comments":true,"path":"2023/11/27/Altium Designer/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/11/27/Altium%20Designer/","excerpt":"","text":"Altium Designer 对于原理图元器件，Designator是唯一的， 原理图绘制，图形最重要，库中的元器件的值是可更改的 电容，即cap，NC代表什么意思？nc是纳法和皮法的缩写,它表示电容的大小非常小。具体来说,1 nc等于0.000000001F Altium元器件除了“Comment”处填写参数外，如何额外添加Value值？altium designer在原理图中默认给元器件添加的属性为“Designator”和“Comment”这两种属性，如果是绘制电阻电容这种类型器件时，可以在“Comment”栏填写“Value”值 贴片电容CC0402KRX7R9BB102 画面居中V+D 画三角形实心的？多边形 鼠标左键按住不放，鼠标呈十字状，器件为可移动状态。同时按键盘上的X或Y：X为水平左右翻转；Y为垂直上下翻转 按照不同的划分角度，一个器件可以被分成多个种类 2-2d， 3-3d，vb翻转3D图，按住键盘上的“Shift”键再用鼠标右键可以翻动板子 键盘上的数字键“0（英文字母上面的数字键）”可以实现PCB板的快速调整，按下数字键“9”可以实现PCB板的90度垂直翻转。】 m移动","categories":[],"tags":[]},{"title":"基础电子元器件","slug":"基础电子元器件","date":"2023-11-01T05:59:24.000Z","updated":"2023-12-15T09:09:14.905Z","comments":true,"path":"2023/11/01/基础电子元器件/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/11/01/%E5%9F%BA%E7%A1%80%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/","excerpt":"电阻电阻，即电流在电路中遇到的阻力，描述导体导电性能， 单位是Ω 电阻器分类有固定电阻和可变电阻，如图所示 电阻在原理图的表示方法，R1-R5分别为压敏电阻，普通电阻，普通电阻，可变电阻，电位器 作用：分压，限流，测温，防浪涌 电阻器参数： 标称阻值，IEC规定了一些系列：E12(±10%) E24(±5%) E48(±2%) E192(±0.5%, ±0.25%, ±0.1%等) 。 允许误差，误差数值用D，F、G、J、K、M等符合表示，表明分别具有±0.5％，±1％、±2％、±5％、±10％、±20％的容许误差 额定功率，在规定的周围温度下，连续工作状态下可使用的最大功率。额定功率越大，体积越大。 选择电阻： 功能 主要参数：阻值，功率，精度 电压","text":"电阻电阻，即电流在电路中遇到的阻力，描述导体导电性能， 单位是Ω 电阻器分类有固定电阻和可变电阻，如图所示 电阻在原理图的表示方法，R1-R5分别为压敏电阻，普通电阻，普通电阻，可变电阻，电位器 作用：分压，限流，测温，防浪涌 电阻器参数： 标称阻值，IEC规定了一些系列：E12(±10%) E24(±5%) E48(±2%) E192(±0.5%, ±0.25%, ±0.1%等) 。 允许误差，误差数值用D，F、G、J、K、M等符合表示，表明分别具有±0.5％，±1％、±2％、±5％、±10％、±20％的容许误差 额定功率，在规定的周围温度下，连续工作状态下可使用的最大功率。额定功率越大，体积越大。 选择电阻： 功能 主要参数：阻值，功率，精度 电压 电容电容，即装电的容器，是一个储能容器，单位是F uF nF pF 电容在原理图的表示方法，C1-C4分别是可变电容，普通电容，电解电容，钽电容 特点：隔直通交，电压不能突变 作用：储能，滤波，退耦，旁路，LC谐振 选择电容： 功能 材质 电容信道，电压值 电感电感器，即电磁感应元器件，抵制电流变化 电感在原理图的表示方法 特点：通直流阻交流，电流不能突变 作用：滤波，震荡，延迟 选择电感： 电感值 熔断器（保险丝）保险在原理图的表现方法 保险参数： 电压额定值：电路电压值 电流额定值：电路电流÷0.75 熔断特性：熔断时间 分断能力 二极管特点：伏安特性（单向导电，反向击穿），温度特性 选择二极管： 反向饱和漏电流 额定整流电流 最大反向工作电压（击穿电压） 最高工作频率 反向工作时间 三极管三极管，即一块半导体基片上的两个PN结将其隔成基区，发射区和集电区 NPN型，用小电流引导大电流 蜂鸣器参考资料 让你更懂电子元器件——电阻的参数 (baidu.com)让你更懂电子元器件——电阻的参数 (baidu.com) 知乎盐选 | 2.4 常用元器件简介 (zhihu.com)","categories":[{"name":"IC基础","slug":"IC基础","permalink":"https://yanlwsometing.gitee.io/blog/categories/IC%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础电子元器件","slug":"基础电子元器件","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/"}]},{"title":"EDIF","slug":"EDIF","date":"2023-09-28T13:29:41.000Z","updated":"2023-10-18T09:36:31.128Z","comments":true,"path":"2023/09/28/EDIF/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/09/28/EDIF/","excerpt":"","text":"什么是EDIFEDIF是”Electronic Design Interchange Format”的缩写，翻译为电子设计交换格式，它是一种用于描述电子设计的标准文件格式。EDIF文件通常包含了电子设计的结构、元件、连线、信号等信息，以便在不同的电子设计工具之间进行数据交换和共享。 EDIF语句所有EDIF语句都由一个开括号、一个关键字、一些参数和一个闭括号组成。参数可以是其他语句，这就赋予了EDIF结构。实际上，一个EDIF文件只包含一条语句: (edif parameters) EDIF结构12345678910111213141516(edif name (status information) (design where-to-find-them) (external reference-libraries) (library name (technology defaults) (cell name (viewmap map) (view type name (interface external) (contents internal) ) ) )) instanceNamdef ? edif用途？ 一个元件的功能由哪些定义？即通过哪些参数就可以复刻一个元件 为什么不区分元件？因为线是唯一的，元件是相同的 参考资料 https://www.iue.tuwien.ac.at/phd/minixhofer/node53.html","categories":[],"tags":[]},{"title":"Ocaml（一）","slug":"Ocaml（一）","date":"2023-09-15T05:33:27.000Z","updated":"2023-12-15T09:08:07.803Z","comments":true,"path":"2023/09/15/Ocaml（一）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/09/15/Ocaml%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"1. let let 既不是变量声明，也不是变量赋值，而是把一个变量与不同类型的值相关联，这些关联对组成的序列称为“环境”。 命令式语言的变量声明是给变量分配一个固定的空间，变量赋值式对这个空间的内容进行修改。 但是，let则是给变量动态地分配一个空间。 eg: 12345678let i = 1;;(* val i : int = 1 *)let a = 1.2;;(* val a : float = 1.2 *)let i = a;(* val i : float = 1.2 *)(* env = [(i, 1); (a, 1.2); (i, 1.2)] 前一个i自动失效*) 局部定义1let val = exp1 in exp2 注： 系统对表达式的回应以-开始，对定义的回应以val开始","text":"1. let let 既不是变量声明，也不是变量赋值，而是把一个变量与不同类型的值相关联，这些关联对组成的序列称为“环境”。 命令式语言的变量声明是给变量分配一个固定的空间，变量赋值式对这个空间的内容进行修改。 但是，let则是给变量动态地分配一个空间。 eg: 12345678let i = 1;;(* val i : int = 1 *)let a = 1.2;;(* val a : float = 1.2 *)let i = a;(* val i : float = 1.2 *)(* env = [(i, 1); (a, 1.2); (i, 1.2)] 前一个i自动失效*) 局部定义1let val = exp1 in exp2 注： 系统对表达式的回应以-开始，对定义的回应以val开始 2. 类型类型是对值的分类。 类型分为两类：系统预定义的基本类型，和在基本类型基础上构造的类型 整数运算和浮点运算不能混合，因为Ocaml不需要指明变量类型，所以运算符没有重载机制； 凡是浮点运算，运算符后都要加上.; unit类型：（） = 和 &lt;&gt; 是结构化比较， == 和 !=是物理比较；浮点数和字符串是结构化数据，整数和字符是非结构化数据； 3. 函数12let f x1 x2 ... xn = explet f (x1, x2, ... xn) = exp 函数变量函数体内的变量分为两种：局部变量和资源变量。 局部变量是指函数定义中引入的变量，包括函数参数，由let局部定义引入的变量以及模式变量。除此之外的变量都是自由变量。自由变量取值不仅是数据，也可以是函数。 对于自由变量的取值有两种处理方法：动态取值和静态取值。 动态取值，也称动态作用域（dynamic scoping），指自由变量的值是函数调用时所见的值。静态取值，也称静态作用域（static scoping），还称字典域（lexical scoping），指自由变量的值是函数定义所见的值。 Ocaml采用的是静态作用域。 1234567891011let x1 = 1let f x = x + x1f 2(* - : int = 3 *)let x1 = 2f 2(* - : int = 3 *) 函数表达式12let f = fun x y -&gt; explet f = function (x, y) -&gt; exp 函数表达式起源于λ演算，称为函数抽象，也称λ表达式。函数表达式的格式在计算机内部更为基本。 fun可以有多个参数，function只能有一个；function可以直接做模式匹配，fun不可以。 高阶函数高阶函数是输入参数为函数或者输出值为函数的函数。 高阶函数与类型推导密不可分。","categories":[{"name":"OCaml","slug":"OCaml","permalink":"https://yanlwsometing.gitee.io/blog/categories/OCaml/"}],"tags":[{"name":"ocaml语法","slug":"ocaml语法","permalink":"https://yanlwsometing.gitee.io/blog/tags/ocaml%E8%AF%AD%E6%B3%95/"}]},{"title":"Verilog-ams","slug":"Verilog-ams","date":"2023-09-09T08:40:35.000Z","updated":"2023-12-15T09:08:49.284Z","comments":true,"path":"2023/09/09/Verilog-ams/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/09/09/Verilog-ams/","excerpt":"语言概述Verilog-AMS语言是一种高层次的模块化硬件描述语言，它用模块的形式来描述模拟系统及其子系统的结构和行为。Verilog-AMS语言可分为数字电路描述子集Verilog-HDL和模拟电路描述子集Verilog-A。 Verilog-AMS语言对模拟电路的描述可以分成两种类型：行为描述与结构描述。 行为描述是指用一些数学表达式或者传输函数来描述目标电路的行为，其描述范围可以从基本的电阻、电容到十分复杂的滤波器或其他模拟系统； 结构描述则是对各个子模块在系统中 的用途以及子模块与子模块之间的连接关系进行描述，这可以理解为是对系统结构框图的描述。完整的结构描述需要包括对信号、端口和基本参数的定义。 Verilog-Ams的行为模为模式如下图所示： Verilog-AMS是由模块构成的，每个模块的内容都镶嵌在module-endmodule 两个语句之间，每个模块实现特定的功能，模块可以进行层次嵌套； Verilog-AMS的行为建模，关于模拟电路部分(即Verilog-A)使用的是analog关键字，关于数字电路部分(即Verilog)则用的是always 和 initial。 注：没有在Verilog-HDL中出现的新东西，自动认为是属于Verilog-A的部分","text":"语言概述Verilog-AMS语言是一种高层次的模块化硬件描述语言，它用模块的形式来描述模拟系统及其子系统的结构和行为。Verilog-AMS语言可分为数字电路描述子集Verilog-HDL和模拟电路描述子集Verilog-A。 Verilog-AMS语言对模拟电路的描述可以分成两种类型：行为描述与结构描述。 行为描述是指用一些数学表达式或者传输函数来描述目标电路的行为，其描述范围可以从基本的电阻、电容到十分复杂的滤波器或其他模拟系统； 结构描述则是对各个子模块在系统中 的用途以及子模块与子模块之间的连接关系进行描述，这可以理解为是对系统结构框图的描述。完整的结构描述需要包括对信号、端口和基本参数的定义。 Verilog-Ams的行为模为模式如下图所示： Verilog-AMS是由模块构成的，每个模块的内容都镶嵌在module-endmodule 两个语句之间，每个模块实现特定的功能，模块可以进行层次嵌套； Verilog-AMS的行为建模，关于模拟电路部分(即Verilog-A)使用的是analog关键字，关于数字电路部分(即Verilog)则用的是always 和 initial。 注：没有在Verilog-HDL中出现的新东西，自动认为是属于Verilog-A的部分 数据类型Verilog-AMS 支持 Verilog HDL 中的integer、real以及parameter 数据类型。 1234integer num = 10; // 单个的整型变量 integer flag [7:0]; // 8个整数组成的数组 real pi = 3.1415926; // 单个的实数型变量parameter real tc = 1.5m from (0:3m); 但是，和 Verilog-HDL 使用parameter类型的中有所不同，Verilog-AMS拓宽了parameter 类型在模拟电路中的功能： 在 Verilog-HDL中，parameter 类型的变量是常数，一旦被定义并分配了初始值，就不能在模拟过程中改变它们的值。 在Verilog-A中，参数的默认值可以在模拟电路的不同部分或不同阶段中根据需要进行更改，以适应不同的仿真条件或电路行为。定义参数的范围，是为了确保参数的取值在模拟中是合理的，以避免出现不合理的模拟结果或错误。 在Verilog-AMS中，一个模块如果包含端口，那么必须进行端口说明。端口必须具有一定的类型和方向。Verilog-AMS语句可以描述很多的守恒系统和信号流程系统，例如电磁流体力学和热力学系统等等。因此，在Verilog-AMS模型中，端口也具有多种类型。 其中，在电学特性中，有电压型voltage、电流型current或者同时具有两种特性electrical。对于常用的electrical类型，需要用到数据类型 discipline。 discipline类型， 用于定义自定义的仿真控制规则，其使用方法如下： 12345678910111213141516module my_discipline; // 定义一个 discipline 变量 discipline my_discipline_var &#123; real voltage across; real current through; &#125; my_discipline_instance; // discipline 方法，用于定义仿真规则 method void initialize() &#123; // 初始化代码 &#125; method void post_solve() &#123; // 后处理代码 &#125;endmodule discipline类似于面向对象编程的class，用 discipline 关键字来定义一个叫 electrical 的「类」，通过electrical定义的对象，在电路中就相对于一个节点。 运算符与表达式Verilog-A支持Verilog中的常规运算符，如+ * % / ， 并且优先级一致。 Verilog-A内置常规表达式，用来提供一些数学运算功能，例如sin(x); ln(x); exp(x); pow(x, y)，和模拟电路中常用的物理量 1234$realtime; // Current simulation time in seconds.$temperature; // Ambient temperature in kelvin. $vt Thermal; // voltage (kT/q). $vt(temp); // Thermal voltage at given temperature. Verilog-A提供模拟信号访问函数，用来访问两个节点间的电压，例如V(x,y)和I(x,y) 为了便于实现模拟电路系统性能与物理实现之间的优化设计，方便定义输入与输出信号之间的数学函数关系，Verilog-AMS提供了多层次的行为和结构模型及多种行为模块描述函数： 时间积分函数idt() 时间微分函数ddt() 转换整形函数slew() 拉普拉斯变换函 数laplace zp() 延迟函数delay() Verilog-A将对模拟信号赋值的运算符称为模拟运算符，写作&lt;+ ，该运算符只能用在analog begin ... end的行为描述中，例如： 1V(a, b) &lt;+ R * I(a, b); // 赋予节点a和b之间一个电阻特性，阻值为R。（相当于在节点a和b之间定义了一个阻值为R的电阻） 使用方法电阻和电导123456789101112// Linear resistor(resistance formulation)`include &quot;disciplines.v&quot;module resistor(p, n); parameter real r = 0; // resistance(Ohms) inout p, n; electrical P, n; analog begin V(p, n) &lt;+ r * I(p, n); endendmodule 123456789101112// Linear conductor(conductance formulation)`include &quot;disciplines.v&quot;module conductor(p, n); parameter real g =0； // conductance(Simens) inout p, n; electrical p, n; analog begin I(p, n) &lt;+ g*V(p, n); endendmodule 电容和电感123456789101112// Linear capacitor`include &quot;disciplines.v&quot;module capacitor(p, n)； parameter real c = 0; // capacitance(F) inout p, n; electrical p, n; analog begin I(p, n) &lt;+ c*ddt(V(p，n)); endendmodule 123456789101112// Linear inductor`include &quot;disciplines.v&quot;module inductor(p,n); parameter real l = 0; // inductance(H) inout p,n; electrical p, n; analog begin V(p, n) &lt;+ l*ddt(I(p,n)); endendmodule 电压源和电流源123456789101112131415161718192021222324// DC voltage source`include &quot;disciplines.v&quot;module vsro(p,n); parameter real dc=O; // dc voltage(V) output p,n; electrical P，n； analog begin V(p,n) &lt;+ dc; endendmodule// DC current source&#x27;include &quot;disciplines.v&quot;module isrc(p,n); parameter real dc=O; //de current(A) output p,n; electrical p,n; analog begin I(p,n) &lt;+ dc; endendmodule 电路模型1234567891011// A simple circuit`include &quot;discipline.v&quot;`include &quot;vsrc.valilS&quot;`include &quot;resistor.vams&quot;module simple_circuit; electrical n; ground grid; vsrc #(．dc(1)) V1(n，gnd); resistor #(．r(1k)) R1(n，gad);endmodule 参考资料 基于Verilog-AMS的高速DAC高层次模型研究 (iczhiku.com) Verilog-A 语言简单入门教程 – Analog-Life Verilog-AMS Language Reference Manual (designers-guide.org)","categories":[{"name":"Verilog","slug":"Verilog","permalink":"https://yanlwsometing.gitee.io/blog/categories/Verilog/"}],"tags":[]},{"title":"Verilog","slug":"Verilog","date":"2023-09-09T08:35:40.000Z","updated":"2023-12-15T09:24:28.871Z","comments":true,"path":"2023/09/09/Verilog/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/09/09/Verilog/","excerpt":"Verilog1. Verilog语言如何用于模拟电路设计的Verilog是一种硬件描述语言（HDL），通常用于模拟和设计数字电路。下面是使用Verilog语言进行电路设计和模拟的一般步骤： 编写Verilog代码：首先，您需要编写Verilog代码来描述您的电路。Verilog代码将包括模块定义、输入和输出端口、内部逻辑以及任何需要的组件实例化。这个代码将描述电路的结构和功能。 设计层次结构：将电路分解为模块和子模块，以便更容易管理和维护代码。这有助于提高代码的可重用性和可维护性。 模拟器选择：选择一个Verilog模拟器，如XSIM、ModelSim、VCS等。模拟器将用于运行Verilog代码并模拟电路的行为。 创建测试台：编写测试台代码，用于提供输入信号并捕获输出信号。测试台代码通常包括测试向量生成、时钟生成以及对电路行为的监视。 编译和仿真：使用Verilog模拟器编译Verilog代码并运行仿真。仿真将模拟电路的运行，并根据输入信号模拟输出信号。 分析仿真结果：分析仿真输出以验证电路的正确性。检查输出是否与预期结果一致，以确保电路按照设计规范工作。 优化和修改：根据仿真结果，对Verilog代码进行优化或修改，以改进电路性能或修复问题。 重复测试：重复上述步骤，直到满足设计规范和性能要求。 综合和实际实现：一旦满足了设计规范，可以将Verilog代码综合成门级电路，并使用工具如Xilinx Vivado、Synopsys Design Compiler等将其映射到FPGA或ASIC。 验证硬件：在实际硬件上验证电路，确保它在实际环境中正常工作。 总之，Verilog语言是一种强大的工具，用于模拟和设计数字电路。通过编写Verilog代码并使用仿真器，您可以有效地验证电路的功能和性能，然后将其实现在硬件中。这个过程通常在数字电路设计中扮演着关键的角色。","text":"Verilog1. Verilog语言如何用于模拟电路设计的Verilog是一种硬件描述语言（HDL），通常用于模拟和设计数字电路。下面是使用Verilog语言进行电路设计和模拟的一般步骤： 编写Verilog代码：首先，您需要编写Verilog代码来描述您的电路。Verilog代码将包括模块定义、输入和输出端口、内部逻辑以及任何需要的组件实例化。这个代码将描述电路的结构和功能。 设计层次结构：将电路分解为模块和子模块，以便更容易管理和维护代码。这有助于提高代码的可重用性和可维护性。 模拟器选择：选择一个Verilog模拟器，如XSIM、ModelSim、VCS等。模拟器将用于运行Verilog代码并模拟电路的行为。 创建测试台：编写测试台代码，用于提供输入信号并捕获输出信号。测试台代码通常包括测试向量生成、时钟生成以及对电路行为的监视。 编译和仿真：使用Verilog模拟器编译Verilog代码并运行仿真。仿真将模拟电路的运行，并根据输入信号模拟输出信号。 分析仿真结果：分析仿真输出以验证电路的正确性。检查输出是否与预期结果一致，以确保电路按照设计规范工作。 优化和修改：根据仿真结果，对Verilog代码进行优化或修改，以改进电路性能或修复问题。 重复测试：重复上述步骤，直到满足设计规范和性能要求。 综合和实际实现：一旦满足了设计规范，可以将Verilog代码综合成门级电路，并使用工具如Xilinx Vivado、Synopsys Design Compiler等将其映射到FPGA或ASIC。 验证硬件：在实际硬件上验证电路，确保它在实际环境中正常工作。 总之，Verilog语言是一种强大的工具，用于模拟和设计数字电路。通过编写Verilog代码并使用仿真器，您可以有效地验证电路的功能和性能，然后将其实现在硬件中。这个过程通常在数字电路设计中扮演着关键的角色。 2. 编写Verilog代码2-1. 建模方式 结构化建模 结构化建模主要通过逐层实例化子模块的方式来描述电路的功能。 数据流建模 ​ 数据流建模主要是通过连续赋值语句 assign 来描述电路的功能 行为建模 2-2. 常用的语法(1) 变量类型类型主要用到有： wire、reg、 parameter wire 类型表示硬件单元之间的物理连线， 本身并没有记忆的功能。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。 reg 类型用来表示存储单元，它会保持数据原有的值，直到被改写 parameter 类型用来表示常量，只能被定义一次 (2) 连续过程赋值连续过程赋值使用关键词assign 对 wire类型的变量进行赋值 1assign LHS_target = RHS_expression LHS_target 必须是一个标量或者线型向量，而不能是寄存器类型。 RHS_expression 的类型没有要求，可以是标量或线型或存器向量，也可以是函数调用。 只要 RHS_expression 表达式的操作数有事件发生（值的变化）时，RHS_expression 就会立刻重新计算，同时赋值给 LHS_target。 (3) always语句一个模块中可以包含多个 always 语句，这些语句在模块间并行执行，与其在模块的前后顺序没有关系。（此处会出现问题，涉及过程赋值） always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。 (4) 过程赋值过程性赋值是在 initial 或 always 语句块里的赋值，赋值对象是寄存器、整数、实数等类型， 过程赋值包括阻塞赋值和非阻塞赋值。 非阻塞(Non_Blocking)赋值方式( 如 b &lt;&#x3D; a; ) 块结束后才完成赋值操作。 b的值并不是立刻就改变的。 这是一种比较常用的赋值方法。（特别在编写可综合模块时） 阻塞(Blocking)赋值方式( 如 b &#x3D; a; ) 赋值语句执行完后,块才结束。 b的值在赋值语句执行完后立刻就改变的。 可能会产生意想不到的结果。 在描述组合逻辑的always 块中用阻塞赋值，则综合成组合逻辑的电路结构。在描述时序逻辑的always 块中用非阻塞赋值，则综合成时序逻辑的电路结构 (5) 函数在 Verilog 中，可以利用任务（关键字为 task）或函数（关键字为 function），将重复性的行为级设计进行提取，并在多个地方调用，来避免重复代码的多次编写，使代码更加的简洁、易用 12345function [range-1:0] function_id ;input_declaration ; other_declaration ;procedural_statement ;endfunction (6) generategenerate关键字用于在编译时生成模块的一部分代码。generate块允许根据条件、参数或其他参数化的方式生成不同的硬件描述。这对于需要根据设计配置或条件生成不同版本的电路非常有用。 条件生成：生成块可以根据条件来包含或排除特定的硬件描述。例如，您可以根据参数来选择是否包含某个模块： 12345verilogCopy codegenerateif (ENABLE_FEATURE) begin // 生成某个模块或逻辑endendgenerate 循环生成：generate块可以用于生成重复的硬件元素，例如一组相似的输入通道或处理单元： 12345verilogCopy codegeneratefor (i = 0; i &lt; N; i = i + 1) begin // 生成N个相似的硬件元素endendgenerate 参数化生成：您可以使用参数化的方式来生成硬件，例如根据输入的宽度或其他参数来生成不同大小的模块： 1234verilogCopy codeparameter WIDTH = 8; // 输入宽度generate // 使用WIDTH参数生成不同大小的硬件endgenerate 层次生成：您可以在一个generate块中嵌套另一个generate块，以实现更复杂的层次结构。 123456verilogCopy codegenerate // 外层generate块 generate // 内层generate块 endgenerateendgenerate 3. Verilog开发工具3-1 Verilator新手试水： https://blog.csdn.net/Daturasee/article/details/124488821 官方文档： Overview — Verilator 5.012 documentation (veripool.org) 进阶文档： https://www.itsembedded.com/","categories":[{"name":"Verilog","slug":"Verilog","permalink":"https://yanlwsometing.gitee.io/blog/categories/Verilog/"}],"tags":[]},{"title":"SF-1-Logic","slug":"SF-1-Logic","date":"2023-07-22T02:43:43.000Z","updated":"2023-12-15T09:08:34.190Z","comments":true,"path":"2023/07/22/SF-1-Logic/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/07/22/SF-1-Logic/","excerpt":"前言在前面的学习中，我们证明了大量的命题：*’相等性命题’*（e1 &#x3D; e2）、蕴含式（P → Q）和量化命题 （∀ x, P x），在本章中，我们将会看到如何用 Coq 解决类似形式的逻辑推理。 对于*命题(Prop)*，有这如下的特点： 所有语法形式良好的命题，无论是否为真，其类型均为 Prop 命题还是*’一等的（First-Class）’*实体， 即在 Coq 的世界中，我们可以像操作其它实体那样操作命题 命题可既以出现在 Theorem（还有 Lemma 以及 Example）的声明中，也可以用 Definition 为命题取名，之后我们可以在任何需要此命题的地方使用它们名字 *’参数化’*的命题 – 也就是一个接受某些类型的参数， 然后返回一个命题的函数","text":"前言在前面的学习中，我们证明了大量的命题：*’相等性命题’*（e1 &#x3D; e2）、蕴含式（P → Q）和量化命题 （∀ x, P x），在本章中，我们将会看到如何用 Coq 解决类似形式的逻辑推理。 对于*命题(Prop)*，有这如下的特点： 所有语法形式良好的命题，无论是否为真，其类型均为 Prop 命题还是*’一等的（First-Class）’*实体， 即在 Coq 的世界中，我们可以像操作其它实体那样操作命题 命题可既以出现在 Theorem（还有 Lemma 以及 Example）的声明中，也可以用 Definition 为命题取名，之后我们可以在任何需要此命题的地方使用它们名字 *’参数化’*的命题 – 也就是一个接受某些类型的参数， 然后返回一个命题的函数 逻辑联结词1. 合取命题 A 与 B 的*’合取’（即‘逻辑与’*）写作 A ∧ B，表示一个 A 与 B 均为真的断言。 证明合取的命题通常使用 split 策略。它会分别为语句的两部分生成两个子目标： 1234567Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4.Proof. split. - (* 3 + 4 = 7 *) reflexivity. - (* 2 * 2 = 4 *) reflexivity.Qed. 如果当前证明上下文中存在形如 A ∧ B 的前提 H，那么 destruct H as [HA HB] 将会从上下文中移除 H 并增加 HA 和 HB 两个新的前提： 123456789Lemma and_example2 : forall n m : nat, n = 0 /\\ m = 0 -&gt; n + m = 0.Proof. (* WORKED IN CLASS *) intros n m H. destruct H as [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity.Qed. 也可以在引入 H 的同时对其进行解构： 1234567Lemma and_example2&#x27; : forall n m : nat, n = 0 /\\ m = 0 -&gt; n + m = 0.Proof. intros n m [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity.Qed. 当某些上下文中只需要合取的一部分时，可以用 destruct 进行解构（或许是作为 intros 的一部分）并用下划线模式 _ 来丢弃不需要的合取分式 1234567Lemma and_example2&#x27; : forall n m : nat, n = 0 /\\ m = 0 -&gt; n + m = 0.Proof. intros n m [Hn _]. rewrite Hn. rewrite Hm. reflexivity.Qed. 顺便一提，中缀记法 ∧ 只是 and A B 的语法糖而已； and 是 Coq 中将两个命题合并成一个命题的运算符 2. 析取析取，即两个命题的*’逻辑或’*：若 A 或 B 二者之一为真，则 A ∨ B 为真。（这种中缀记法表示 or A B，其中 or : Prop → Prop → Prop。 证明某个析取命题成立，只需证明其任意一边的命题成立就够了。 123456Lemma or_intro_l : forall A B : Prop, A -&gt; A \\/ B.Proof. intros A B HA. left. apply HA.Qed. 在证明中使用析取前提，我们需要分类讨论，可以显式地通过 destruct 或隐式地通过 intros 模式来拆分： 123456789101112Lemma factor_is_O: forall n m : nat, n = 0 \\/ m = 0 -&gt; n * m = 0.Proof. (* This pattern implicitly does case analysis on [n = 0 \\/ m = 0] *) intros n m [Hn | Hm]. - (* Here, [n = 0] *) rewrite Hn. reflexivity. - (* Here, [m = 0] *) rewrite Hm. rewrite &lt;- mult_n_O. reflexivity.Qed. 3. 假命题与否定Coq能证明某些东西是*’真’的，也能证明某些给定的命题‘不是’*真的，这样的否定语句使用逻辑否定运算符 ~ 来表达。 当我们假设了矛盾存在时，就能推出任何命题。 遵循这一直觉，我们可以可以将 ~ P（即非 P）定义为 ∀ Q, P → Q。 不过 Coq 选择了稍有些不同（但等价）的做法，它将 ~ P 定义为 P → False，而 False 是在标准库中特别定义的矛盾性命题。 12345678Module NotPlayground.Definition not (P:Prop) := P -&gt; False.Notation &quot;~ x&quot; := (not x) : type_scope.Check not : Prop -&gt; Prop.Check False.End NotPlayground. 由于 False 是个矛盾性命题，因此爆炸原理对它也适用。如果我们让 False 进入到了证明的上下文中，可以对它使用 destruct 来完成任何待证目标。 1234567Theorem ex_falso_quodlibet : forall (P:Prop), False -&gt; P.Proof. (* WORKED IN CLASS *) intros P contra. destruct contra. Qed. 不等性是十分常见的否定句的例子，，它有一个特别的记法 x ≠ y： 1Notation &quot;x &lt;&gt; y&quot; := (~(x = y)). 由于用 ex_falso_quodlibet 推理十分常用，因此 Coq 提供了内建的策略 exfalso。 由于不等性包含一个否定，因此在能够熟练地使用它前还需要一些练习。 这里有个有用的技巧：如果你需要证明某个目标不可能时（例如当前的目标陈述为 false &#x3D; true），请使用 ex_falso_quodlibet 将该目标转换为 False。 123456789101112Theorem not_true_is_false : forall b : bool, b &lt;&gt; true -&gt; b = false.Proof. intros b H. destruct b eqn:HE. - (* b = true *) unfold not in H. apply ex_falso_quodlibet. apply H. reflexivity. - (* b = false *) reflexivity.Qed. 4. 真值与经常使用的 False 不同，True 很少使用，因为它作为证明目标来说过于平凡， 而作为前提又不携带任何有用的信息 5. 逻辑等价联结词“当且仅当”用起来十分方便，它是两个蕴含式的合取， 断言了两个命题拥有同样的真值 1234567Definition iff (P Q : Prop) := (P -&gt; Q) /\\ (Q -&gt; P).Notation &quot;P &lt;-&gt; Q&quot; := (iff P Q) (at level 95, no associativity) : type_scope.End IffPlayground. 6. 广集与逻辑等价“广集（Setoid）”指配备了等价关系的集合，即满足自反性、对称性和传递性的关系。 当一个集合中的两个元素在这种关系上等价时，可以用 rewrite 将其中一个元素替换为另一个。为了开启此行为，我们需要导入 Coq 库来支持它： 1From Coq Require Import Setoids.Setoid. 12345678910Lemma mul_eq_0 : forall n m, n * m = 0 &lt;-&gt; n = 0 \\/ m = 0.Theorem or_assoc : forall P Q R : Prop, P \\/ (Q \\/ R) &lt;-&gt; (P \\/ Q) \\/ R.Lemma mul_eq_0_ternary : forall n m p, n * m * p = 0 &lt;-&gt; n = 0 \\/ m = 0 \\/ p = 0.Proof. intros n m p. rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc. reflexivity.Qed. 7. 存在量化*’存在量化’*也是十分重要的逻辑联结词。我们说存在某个类型为 T 的 x，使得某些性质 P 对于 x 成立，写作 ∃ x : T, P。 为了证明形如 ∃ x, P 的语句，我们必须证明 P 对于某些特定的 x 成立，这些特定的 x 被称作存在性的*’例证’*。 首先，我们调用 ∃ t 策略向 Coq 指出已经知道了使 P 成立的例证 t 然后证明将所有出现的 x 替换成 t 的命题 P 如果我们的的上下文中有形如 ∃ x, P 的存在前提， 可以将其解构得到一个例证 x 和一个陈述 P 对于 x 成立的前提。 12345678Theorem exists_example_2 : forall n, (exists m, n = 4 + m) -&gt; (exists o, n = 2 + o).Proof. (* WORKED IN CLASS *) intros n [m Hm]. exists (2 + m). apply Hm. Qed. 使用命题编程逻辑联结词，使得我们能够用简单命题去构造复杂命题，例如定义函数返回一个命题： 12345Fixpoint In &#123;A : Type&#125; (x : A) (l : list A) : Prop := match l with | [] =&gt; False | x&#x27; :: l&#x27; =&gt; x&#x27; = x \\/ In x l&#x27; end. 虽然递归定义命题在某些情况下会很方便，但这种方式也有其劣势。特别是， 这类命题会受到 Coq 对递归函数要求的限制，例如，在 Coq 中递归函数必须是 “明显会终止”的。 对参数应用定理Coq 不同于其它证明助理（如 ACL2 和 Isabelle）的一个特性是， 它将*’证明’*本身也作为一等对象。 我们已经知道 Check 命令可以用来显式表达式的类型了， 不过它还可以用来查找某个标识符所指代的定理。 12Check plus : nat -&gt; nat -&gt; nat.Check add_comm : forall n m : nat, n + m = m + n. 在检查定理 plus_comm 的*’陈述’时，Coq 使用了与检查某项的‘类型’*一样的方式 （如果我们保留以冒号开始的部分，那么它会被打印出来）。这是为什么？ 原因在于标识符 plus_comm 其实指代的是被称作*’证明对象’的数据结构， 它表示在命题 ∀ n m : nat, n + m &#x3D; m + n 的真实性上建立的逻辑推导。 此对象的类型‘就是’*其所证命题的陈述。 例如，若我们有一个类型为 nat → nat → nat 的项，就可以给它两个 nat 作为参数并得到一个 nat。 类似地，如果我们有一个类型为 n &#x3D; m → n + n &#x3D; m + m 的对象， 就能为它提供一个类型为 n &#x3D; m 的“参数”并推导出 n + n &#x3D; m + m。 12345678910111213141516171819202122232425262728293031323334353637383940414243Lemma in_not_nil_42 : forall l : list nat, In 42 l -&gt; l &lt;&gt; [].Proof. intros l H. Fail apply in_not_nil.Abort.(** There are several ways to work around this: *)(** Use [apply ... with ...] *)Lemma in_not_nil_42_take2 : forall l : list nat, In 42 l -&gt; l &lt;&gt; [].Proof. intros l H. apply in_not_nil with (x := 42). apply H.Qed.(** Use [apply ... in ...] *)Lemma in_not_nil_42_take3 : forall l : list nat, In 42 l -&gt; l &lt;&gt; [].Proof. intros l H. apply in_not_nil in H. apply H.Qed.(** Explicitly apply the lemma to the value for [x]. *)Lemma in_not_nil_42_take4 : forall l : list nat, In 42 l -&gt; l &lt;&gt; [].Proof. intros l H. apply (in_not_nil nat 42). apply H.Qed.(** Explicitly apply the lemma to a hypothesis. *)Lemma in_not_nil_42_take5 : forall l : list nat, In 42 l -&gt; l &lt;&gt; [].Proof. intros l H. apply (in_not_nil _ _ _ H).Qed. Coq vs. 构造逻辑1. 函数的外延性由于 Coq 的相等关系运算符是多态的， 因此我们可以在*’任何’类型上使用它。特别是，我们可以写出断言‘两个函数相等’*的命题 在一般的数学研究中，对于任意两个函数 f 和 g， 只要它们对相同的输入产生相等的结果，那么它们就被认为相等： (∀ x, f x &#x3D; g x) → f &#x3D; g 这被称作*’函数的外延性原理’*。 然而，函数的外延性并不在 Coq 的基本公理之内，因此某些“合理”的命题是不可证明的，不过我们可以用 Axiom 指令将函数的外延性添加到 Coq 的核心逻辑系统中。 123Axiom functional_extensionality : ∀ &#123;X Y: Type&#125; &#123;f g : X → Y&#125;, (∀ (x:X), f x = g x) → f = g. 将某个东西用 Axiom 定义为公理的效果与陈述一个定理并用 Admitted 跳过其证明相同， 不过它会提醒读者这是一个公理，我们无需证明！ 123456Example function_equality_ex2 : (fun x ⇒ plus x 1) = (fun x ⇒ plus 1 x).Proof. apply functional_extensionality. intros x. apply plus_comm.Qed. 我们可以用Print Assumptions 指令查看某个证明依赖的所有附加公理 123456Print Assumptions function_equality_ex2.(* ===&gt; Axioms: functional_extensionality : forall (X Y : Type) (f g : X -&gt; Y), (forall x : X, f x = g x) -&gt; f = g *) 2. 命题 vs. 布尔值在 Coq 中有两种编码逻辑事实的方式，即使用*’布尔值’* （类型为 bool）和*’命题’*（类型为 Prop）。 bool Prop decidable? yes no useable with match? yes no equalities rewritable? no yes 这二者最本质的区别在于可判断性。bool是具体的，只有两个固定的值，而Prop是泛化的，Prop类型的值可以代表一个可证明的命题，也可以代表一个无法证明的命题。 第二行是直接从这个本质区别出发的。要计算布尔值上的模式匹配(或条件匹配)，我们需要知道被检查者的计算结果是真还是假;这只适用于bool，而不是Prop。 第三行突出了另一个重要的实际区别:像eqb_nat这样返回布尔值的相等函数不能直接用于证明重写是正确的，而命题eq则可以。 由于Prop包含可决定和不可决定的属性，当我们想要形式化一个恰好是可决定的属性时，我们有两种选择:我们可以将其表示为布尔计算或表示为Prop中的函数。 例如，我们可以通过以下两种方式来断言 n 为偶数： 12Example even_42_bool : evenb 42 = true.Proof. reflexivity. Qed. 12Example even_42_prop : even 42.Proof. unfold even. ∃ 21. reflexivity. Qed. 然而，即便布尔值和命题式在逻辑上是等价的， 但它们的方便性从某些特定的目上来看并不一样。 无法在函数的定义中测试一般的命题是否为真，原因与 Coq 核心语言的*’可计算性’*特质有关, 因此，在 Coq 中 Prop *’并没有’*一种通用的情况分析操作来确定 任意给定的命题是否为真，一旦存在这种操作，我们就能写出不可计算的函数 通过布尔值来陈述事实会带来一点重要的优势，即通过对 Coq 中的项进行计算可以实现一些自动推理，这种技术被称为*’互映证明（Proof by Reflection）’* 12Example even_1000&#x27; : evenb 1000 = true.Proof. reflexivity. Qed. 布尔事实”的否定可以被直白地陈述并证明， 只需翻转预期的布尔值结果即可 3. 经典逻辑 vs. 构造逻辑在定义 Coq 函数时是无法判断命题 P 是否成立。 然而*’证明’*也存在类似的限制！ 12Definition excluded_middle := ∀ P : Prop, P ∨ ¬ P. 在证明形如 P ∨ Q 的陈述时，我们使用了 left 与 right 策略，它们能够有效地知道析取的哪边成立。然而，在 excluded_middle 中，P 是被全称量化的*’任意’*命题，我们对它一无所知。 我们没有足够的信息来选择使用 left 或 right 中的哪一个。 然而，如果我们恰好知道 P 与某个布尔项互映，那么就能很轻易地知道它是否成立了： 我们只需检查 b 的值即可。 1234567Theorem restricted_excluded_middle : ∀ P b, (P ↔ b = true) → P ∨ ¬ P.Proof. intros P [] H. - left. rewrite H. reflexivity. - right. rewrite H. intros contra. discriminate contra.Qed. 一般的排中律在 Coq 中默认并不可用，因为它是常见的逻辑系统（如 ZFC）中的标准特性。尽管如此，不假设排中律的成立仍有其独特的优点： Coq 中的陈述可以构造出比标准数学中同样陈述更强的断言。特别是， 当存在 ∃ x, P x 的 Coq 证明时，我们可以直接给出一个使 P x 得证的值 x。换言之，任何关于存在性的证明必定是*’构造性’*的。 像 Coq 一样不假设排中律成立的逻辑系统被称作*’构造逻辑’*。 像 ZFC 这样更加传统的，排中律对于任何命题都成立的逻辑系统则被称作*’经典逻辑’*。 排中律是一个数理逻辑中的原理，它指出对于任意命题 P，P 或者成立，或者不成立，没有中间值。换句话说，排中律断定对于任意命题 P，P ∨ ¬P 恒为真。 在 Coq 中，排中律可以表示为 excluded_middle 假设，它的类型为 forall P : Prop, P \\/ ~P，意味着任意一个命题 P，P 或者 ¬P 成立。 排中律的引入允许我们在证明中使用两种情况的分析，即假设 P 成立和假设 ¬P 成立，并根据这两种情况进行推理。 然而，需要注意的是，排中律在某些情况下可能会导致不可判定或无限推理的问题。因此，在使用排中律时需要谨慎，并考虑是否真正需要使用排中律来证明目标。 即便构造逻辑很有用，它也有自身的限制：存在很多容易用经典逻辑证明的命题， 用构造证明只会更加复杂，而对于某些已知的命题而言这样的构造性证明甚至不存在！ 幸运的是，排中律和函数外延性一样都是与 Coq 的逻辑系统兼容的， 我们可以安全地将它作为公理添加到 Coq 中。然而，在本书中我们不必如此： 我们所涉及的结构都可以完全用构造逻辑得到，所需的额外代价则微不足道。","categories":[{"name":"Coq","slug":"Coq","permalink":"https://yanlwsometing.gitee.io/blog/categories/Coq/"}],"tags":[]},{"title":"SF-1-Tactics","slug":"SF-1-Tactics","date":"2023-07-19T09:19:31.000Z","updated":"2023-12-15T09:08:43.930Z","comments":true,"path":"2023/07/19/SF-1-Tactics/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/07/19/SF-1-Tactics/","excerpt":"apply策略当遇到如下场景时，采用apply策略： 待证目标与上下文中的前提或已证引理*’刚好相同’*的情况 123Theorem silly1 : forall (n m : nat), n = m -&gt; n = m.Proof. intros n m eq. apply eq. Qed. 待证目标存在于一个蕴含式中，就可以配合*’条件（Conditional）’*假设和引理来使用，该蕴含式的前提就会被添加到待证子目标列表中 当我们使用 apply H 时，语句 H 会以一个引入了某些 ‘通用变量（Universal Variables）’ 的 ∀ 开始。在 Coq 针对 H 的结论匹配当前目标时，它会尝试为这些变量查找适当的值 12345678Theorem silly2a : forall (n m : nat), (n,n) = (m,m) -&gt; (forall (q r : nat), (q,q) = (r,r) -&gt; [q] = [r]) -&gt; [n] = [m].Proof. intros n m eq1 eq2. apply eq2. apply eq1. Qed. 变量 q 匹配n ，而 r 匹配m 要使用 apply 策略，被应用的事实（的结论）必须精确地匹配证明目标： 例如, 当等式的左右两边互换后，apply 就无法起效了，这个时候需要采用symmetry","text":"apply策略当遇到如下场景时，采用apply策略： 待证目标与上下文中的前提或已证引理*’刚好相同’*的情况 123Theorem silly1 : forall (n m : nat), n = m -&gt; n = m.Proof. intros n m eq. apply eq. Qed. 待证目标存在于一个蕴含式中，就可以配合*’条件（Conditional）’*假设和引理来使用，该蕴含式的前提就会被添加到待证子目标列表中 当我们使用 apply H 时，语句 H 会以一个引入了某些 ‘通用变量（Universal Variables）’ 的 ∀ 开始。在 Coq 针对 H 的结论匹配当前目标时，它会尝试为这些变量查找适当的值 12345678Theorem silly2a : forall (n m : nat), (n,n) = (m,m) -&gt; (forall (q r : nat), (q,q) = (r,r) -&gt; [q] = [r]) -&gt; [n] = [m].Proof. intros n m eq1 eq2. apply eq2. apply eq1. Qed. 变量 q 匹配n ，而 r 匹配m 要使用 apply 策略，被应用的事实（的结论）必须精确地匹配证明目标： 例如, 当等式的左右两边互换后，apply 就无法起效了，这个时候需要采用symmetry apply with 策略在Coq中，apply策略用于应用一个已证明的引理或定理到当前的目标上。而with关键字则用于给定引理或定理应用的参数。apply with结合起来使用可以在应用引理时指定参数的值。 使用apply with的一般形式如下所示： 1apply lemma_name with (arg1 := val1) (arg2 := val2) ...) 其中，lemma_name是待应用的引理或定理的名称，arg1, arg2, … 是引理或定理中参数的名称，val1, val2, … 是给定参数的值。 下面是一个简单的例子，展示了apply with的使用方式： 123456789Lemma add_comm : forall n m : nat, n + m = m + n.Proof. intros n m， (* 证明... *)Qed.Lemma example : 2 + 3 = 3 + 2.Proof. apply add_comm with (n := 2) (m := 3).Qed. 在这个例子中，我们使用 apply with 在证明 example 中应用 add_comm 引理时指定了参数的具体值 (n := 2) 和 (m := 3)。 The injection and discriminate Tacticsinjection让 Coq 利用构造子的单射性来产生所有它能从 H 所推出的等式，每一个这样的等式都作为假设（本例中为 Hmn）被添加到上下文中。 1234567Theorem S_injective : forall (n m : nat), S n = S m -&gt; n = m.Proof. intros n m H1. injection H as Hnm. apply Hnm.Qed. discriminate 则是利用不相交原则，即两个以不同构造子开始的元素(如O和S，或真和假)永远不可能相等。当假设存在这样的荒谬性时，一切结论皆可证真。 1234Theorem discriminate_ex1 : forall (n : nat), S n = O -&gt; 2 + 2 = 5.Proof. intros n contra. discriminate contra. Qed 本例是逻辑学原理爆炸原理的一个实例，它断言矛盾的前提会推出任何东西， 甚至是假命题！ 对假设使用策略 simpl in H 会对上下文中的假设 H 执行化简 apply L in H 会针对上下文中的假设 H 匹配某些 （形如 X → Y 中的）条件语句 L。然而，与一般的 apply 不同 （它将匹配 Y 的目标改写为子目标 X），apply L in H 会针对 X 匹配 H，如果成功，就将其替换为 Y 换言之，apply L in H 给了我们一种“正向推理”的方式：根据 X → Y 和一个匹配 X 的假设，它会产生一个匹配 Y 的假设。作为对比，apply L 是一种“反向推理”：它表示如果我们知道 X → Y 并且试图证明 Y， 那么证明 X 就足够了。 变换归纳假设在调用 induction 策略前，我们有时需要用 intros 将假设从目标移到上下文中时要十分小心。例如，假设我们要证明 double 函数是单射的 12345678910111213141516171819Fixpoint double (n:nat) := match n with | O =&gt; O | S n&#x27; =&gt; S (S (double n&#x27;)) end. Theorem double_injective_FAILED : forall n m, double n = double m -&gt; n = m.Proof. intros n m. induction n as [| n&#x27; IHn&#x27;]. - (* n = O *) simpl. intros eq. destruct m as [| m&#x27;] eqn:E. + (* m = O *) reflexivity. + (* m = S m&#x27; *) discriminate eq. - (* n = S n&#x27; *) intros eq. destruct m as [| m&#x27;] eqn:E. + (* m = O *) discriminate eq. + (* m = S m&#x27; *) apply f_equal.Abort. 1234567891011121314151617181920212223242526272829303132333435363738394041Theorem double_injective : forall n m, double n = double m -&gt; n = m.Proof. intros n. induction n as [| n&#x27; IHn&#x27;]. - (* n = O *) simpl. intros m eq. destruct m as [| m&#x27;] eqn:E. + (* m = O *) reflexivity. + (* m = S m&#x27; *) discriminate eq. - (* n = S n&#x27; *)(** Notice that both the goal and the induction hypothesis are different this time: the goal asks us to prove something more general (i.e., we must prove the statement for _every_ [m]), but the IH is correspondingly more flexible, allowing us to choose any [m] we like when we apply the IH. *) intros m eq.(** Now we&#x27;ve chosen a particular [m] and introduced the assumption that [double n = double m]. Since we are doing a case analysis on [n], we also need a case analysis on [m] to keep the two &quot;in sync.&quot; *) destruct m as [| m&#x27;] eqn:E. + (* m = O *)(** The 0 case is trivial: *) discriminate eq. + (* m = S m&#x27; *) apply f_equal.(** At this point, since we are in the second branch of the [destruct m], the [m&#x27;] mentioned in the context is the predecessor of the [m] we started out talking about. Since we are also in the [S] branch of the induction, this is perfect: if we instantiate the generic [m] in the IH with the current [m&#x27;] (this instantiation is performed automatically by the [apply] in the next step), then [IHn&#x27;] gives us exactly what we need to finish the proof. *) apply IHn&#x27;. simpl in eq. injection eq as goal. apply goal. Qed. 123456789101112131415161718Theorem double_injective_take2 : forall n m, double n = double m -&gt; n = m.Proof. intros n m. (* [n] and [m] are both in the context *) generalize dependent n. (* Now [n] is back in the goal and we can do induction on [m] and get a sufficiently general IH. *) induction m as [| m&#x27; IHm&#x27;]. - (* m = O *) simpl. intros n eq. destruct n as [| n&#x27;] eqn:E. + (* n = O *) reflexivity. + (* n = S n&#x27; *) discriminate eq. - (* m = S m&#x27; *) intros n eq. destruct n as [| n&#x27;] eqn:E. + (* n = O *) discriminate eq. + (* n = S n&#x27; *) apply f_equal. apply IHm&#x27;. injection eq as goal. apply goal.Qed. 先引入所有量化的变量，然后*’重新一般化（re-generalize）’* 其中的一个或几个，选择性地从上下文中挑出几个变量并将它们放回证明目标的开始处。 用 generalize dependent 策略就能做到。 个人理解1：问题在于，对于intros n , m, eq, eq的非形式化含义为“任意的n和m, double n &#x3D; double m”。在intros n. ..... intros m eq， eq的非形式化含义为“对于任意的n，有m（任意但具体）使double n &#x3D; double m”。因此，需要延后m的引入时间。 个人理解2：先看对比图 在不同位置引入假设，归纳前提结论是不同的，因此图一我们理所应当地认为只要apply IHm&#39;, 就能顺利证明成功，但是Coq不会这么做。 因为IHm&#39;的性质不同，图一的是作为事实陈述的，它的背景含义是（n和m已经确定了）；而图二是作为命题结论的，它的背景含义是任意但确定的n 因此什么时候变换归纳假设，就是在出现像图一那样，看上去假设可用但又用不了的情况。 展开定义unfold 是一个替换操作，用于展开（或展开定义）标识符（变量、函数、定理等）。它的主要作用是将标识符替换为其定义，从而在证明过程中更好地观察和操作项。 unfold 有两种使用方式： 展开单个标识符：可以使用 unfold &lt;identifier&gt; 来展开某个具体的标识符。例如，如果有一个变量 x，你可以使用 unfold x 来将所有出现的 x 替换为其具体的值或定义。 展开多个标识符：如果你想同时展开多个标识符，可以使用 unfold &lt;identifier1&gt;, &lt;identifier2&gt;, ... 的形式。例如，unfold f, g 将展开标识符 f 和 g。 这个指令在证明过程中非常有用，特别是在展开定义或简化复杂的表达式时。通过展开，你可以更加清晰地了解项和其定义之间的关系，并且可以更方便地进行后续的推理和证明。 对复合表达式使用 destructdestruct 可以进行分类来处理一些变量的值了，也可以根据某些*’表达式’*的结果的情况来进行推理。 1234567891011121314Definition sillyfun (n : nat) : bool := if n =? 3 then false else if n =? 5 then false else false.Theorem sillyfun_false : forall (n : nat), sillyfun n = false.Proof. intros n. unfold sillyfun. destruct (n =? 3) eqn:E1. - (* n =? 3 = true *) reflexivity. - (* n =? 3 = false *) destruct (n =? 5) eqn:E2. + (* n =? 5 = true *) reflexivity. + (* n =? 5 = false *) reflexivity. Qed. 由于 n 要么等于 3 要么不等于，因此我们可以用 destruct (eqb n 3) 来对这两种情况进行推理 复习 intros：将前提&#x2F;变量从证明目标移到上下文中 reflexivity：（当目标形如 e &#x3D; e 时）结束证明 apply：用前提、引理或构造子证明目标 apply… in H：将前提、引理或构造子应用到上下文中的假设上（正向推理） apply… with…：为无法被模式匹配确定的变量显式指定 simpl：化简目标中的计算 simpl in H：化简前提中的计算 rewrite：使用相等关系假设（或引理）来改写目标 rewrite … in H：使用相等关系假设（或引理）来改写前提 symmetry：将形如 t&#x3D;u 的目标改为 u&#x3D;t symmetry in H：将形如 t&#x3D;u 的前提改为 u&#x3D;t unfold：用目标中的右式替换定义的常量 unfold… in H：用前提中的右式替换定义的常量 destruct… as…：对归纳定义类型的值进行情况分析 destruct… eqn:…：为添加到上下文中的等式指定名字， 记录情况分析的结果 induction… as…: 对归纳定义类型的值进行归纳 injection: reason by injectivity on equalities between values of inductively defined types discriminate: reason by disjointness of constructors on equalities between values of inductively defined types assert (H: e)（或 assert (e) as H）：引入“局部引理”e 并称之为 H generalize dependent x：将变量 x（以及任何依赖它的东西） 从上下文中移回目标公式内的前提中","categories":[{"name":"Coq","slug":"Coq","permalink":"https://yanlwsometing.gitee.io/blog/categories/Coq/"}],"tags":[]},{"title":"SF-1-Poly","slug":"SF-1-Poly","date":"2023-07-19T09:19:00.000Z","updated":"2023-12-15T09:08:38.579Z","comments":true,"path":"2023/07/19/SF-1-Poly/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/07/19/SF-1-Poly/","excerpt":"多态（Polymorphism）多态，即面对不同类型的数据，同一种方法具有不同的表现形式 1. 多态列表(Polymorphic Lists)在Lists章中，我们创建了自然数类型的列表，但我们需要不同类型的列表就要重新创建，因此我们需要“多态列表” 123Inductive list (X:Type) : Type := | nil | cons (x : X) (l : list X). 其中，list 是个从 Type 类型到 Type 类型的函数。list 的定义中的参数 X 自动 成为构造子 nil 和 cons 的参数。至于具体的列表，它的类型为list X. 1Check (cons nat 3 (nil nat)) : list nat. 其函数的多态版本如下 12345Fixpoint repeat (X : Type) (x : X) (count : nat) : list X := match count with | 0 ⇒ nil X | S count&#x27; ⇒ cons X x (repeat X x count&#x27;) end.","text":"多态（Polymorphism）多态，即面对不同类型的数据，同一种方法具有不同的表现形式 1. 多态列表(Polymorphic Lists)在Lists章中，我们创建了自然数类型的列表，但我们需要不同类型的列表就要重新创建，因此我们需要“多态列表” 123Inductive list (X:Type) : Type := | nil | cons (x : X) (l : list X). 其中，list 是个从 Type 类型到 Type 类型的函数。list 的定义中的参数 X 自动 成为构造子 nil 和 cons 的参数。至于具体的列表，它的类型为list X. 1Check (cons nat 3 (nil nat)) : list nat. 其函数的多态版本如下 12345Fixpoint repeat (X : Type) (x : X) (count : nat) : list X := match count with | 0 ⇒ nil X | S count&#x27; ⇒ cons X x (repeat X x count&#x27;) end. 类型标注的推断(Type Annotation Inference)当不指定参数类型，Coq使用类型推断出其参数类型。 12345Fixpoint repeat&#x27; X x count : list X := match count with | 0 ⇒ nil X | S count&#x27; ⇒ cons X x (repeat&#x27; X x count&#x27;) end. 例如， 由于 X 是作为 cons 的参数使用的，因此它必定是个 Type 类型， 因为 cons 期望一个 Type 作为其第一个参数，而用 0 和 S 来匹配 count 意味着它必须是个 nat，诸如此类 注意：显式的类型标注对于文档和完整性检查来说仍然非常有用 类型参数的推断(Type Argument Synthesis)但是，我们还希望更简单一点。例如，由于 repeat 的第二个参数为 X 类型的元素，第一个参数明显只能是 X， 既然如此，我们何必显式地写出它呢？ Coq 允许避免这种冗余，将类型参数写为 “_” 。当 Coq 遇到 _ 时，它会尝试*’统一’*所有的局部变量信息， 包括函数应当应用到的类型，其它参数的类型，以及应用函数的上下文中期望的类型， 以此来确定 _ 处应当填入的具体类型。 12345Fixpoint repeat&#x27;&#x27; X x count : list X := match count with | 0 ⇒ nil _ | S count&#x27; ⇒ cons _ x (repeat&#x27;&#x27; _ x count&#x27;) end. 隐式参数（Implicit Arguments）类型参数的推断还是复杂，我们希望避免写 _。 Arguments 用于指令指定函数或构造子的名字并列出其参数名， 花括号中的任何参数都会被视作隐式参数。 123Arguments nil &#123;X&#125;.Arguments cons &#123;X&#125; _ _.Arguments repeat &#123;X&#125; x count. 我们还可以在定义函数时就声明隐式参数， 只需要将某个参数两边的圆括号换成花括号 12345Fixpoint repeat&#x27;&#x27;&#x27; &#123;X : Type&#125; (x : X) (count : nat) : list X := match count with | 0 ⇒ nil | S count&#x27; ⇒ cons x (repeat&#x27;&#x27;&#x27; x count&#x27;) end. 123Inductive list&#x27; &#123;X:Type&#125; : Type := | nil&#x27; | cons&#x27; (x : X) (l : list&#x27;). 显式提供类型参数有的时候，Coq判断不出具体的类型，需要直接明确。 1Fail Definition mynil := nil. 可以通过两种方法进行处理这个问题。 第一种是通过显示指定目标的类型，使得coq能够进行自动推导 Definition mynil : list nat := nil.第二种是使用@来暂时性地禁用隐式参数，从而显示的给出参数 Definition mynil&#39; := @nil nat. 2. 多态序对1234Inductive prod (X Y : Type) : Type :=| pair (x : X) (y : Y).Arguments pair &#123;X&#125; &#123;Y&#125;. prod是类型，pair 1 2 是 prod类型的数据 3. 多态候选123456Inductive option (X:Type) : Type := | Some (x : X) | None.Arguments Some &#123;X&#125;.Arguments None &#123;X&#125;. 函数作为数据（Functions as Data）接收函数作为参数或者使用函数作为返回值的函数称为高阶函数*(Higher-Order Functions)*. 常见的高阶函数包括了filter, map, flat_map, fold等等 1. filter函数filter接收一个函数test，以及一个list，其将list中的每个元素作为参数分别执行test，根据test执行结果来保留其中一部分元素（test执行结果为true的元素） 12345678Fixpoint filter &#123;X:Type&#125; (test: X-&gt;bool) (l:list X) : (list X) := match l with | [] =&gt; [] | h :: t =&gt; if test h then h :: (filter test t) else filter test t end. 2. map函数map接收一个函数f以及一个list，将list中的元素逐个使用f进行转换。 12输入 f [ a b c d e]输出 [ f(a) f(b) f(c) f(d) f(e)] 12345Fixpoint map &#123;X Y: Type&#125; (f:X-&gt;Y) (l:list X) : (list Y) := match l with | [] =&gt; [] | h :: t =&gt; (f h) :: (map f t) end. 3. fold函数fold接收一个函数f，一个list以及一个初始值i，其将list中的元素作为函数f的第一个参数传入，将上一个调用f的结果作为f的第二个参数传入，对list中的元素进行逐个处理，并将最后一次调用f得到的结果作为返回值返回。 12输入 f [a b c] i输出 f(c, f(b, f(a, i))) 1234567Fixpoint fold &#123;X Y: Type&#125; (f: X-&gt;Y-&gt;Y) (l: list X) (b: Y) : Y := match l with | nil =&gt; b | h :: t =&gt; f h (fold f t b) end. 4. 匿名函数(Anonymous Functions)某些短小的，特定的函数可能不需要为其定义一个名称，此时可以使用匿名函数来定义, 匿名函数使用关键字fun来定义 1fun l =&gt; (length l) =? 1) 123456Example test_filter2&#x27;: filter (fun l =&gt; (length l) =? 1) [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ] = [ [3]; [4]; [8] ].Proof. reflexivity. Qed. 值得注意的是，无论是filter还是map，所调用的函数均是处理子元素的 Exercises1. Exercise: 2 stars, standard (fold_length)（证明列表问题，通常采用的是归纳的方法。） 非形式化证明： 123456789101112&#x27;定理&#x27;：对所有类型的列表 l，fold_length l = lenght l. &#x27;证明&#x27;: 通过对 l 使用归纳法。 首先, 假设 l= []。我们必须证明： fold_length [] = lenght []. 这可以通过展开 fold_length 和 lenght 的定义得到。 然后, 假设 l = x::l&#x27;，有： fold_length l&#x27; = lenght l&#x27;. （归纳假设）。我们必须证明： fold_length (x::l&#x27;) = lenght (x::l&#x27;). 根据 length 的定义 , 上式等价于： fold_length (x::l&#x27;) = 1 +lenght (l&#x27;). 该式可通过我们的归纳假设立即证得 12345678Theorem fold_length_correct : forall X (l : list X), fold_length l = length l. Proof. intros. induction l. - reflexivity. - simpl. rewrite &lt;- IHl. reflexivity. Qed. 2. Exercise: 2 stars, advanced (currying) It is possible to convert a function between these two types. Converting from X × Y → Z to X → Y → Z is called currying, in honor of the logician Haskell Curry. Converting from X → Y → Z to X × Y → Z is called uncurrying. 在 Coq 中，函数 f : A → B → C 的类型其实是 A → (B → C)。 也就是说，如果给 f 一个类型为 A 的值，它就会给你函数 f’ : B → C。 如果再给 f’ 一个类型为 B 的值，它就会返回一个类型为 C 的值。 12345Definition prod_curry &#123;X Y Z : Type&#125; (f : X × Y → Z) (x : X) (y : Y) : Z := f (x, y). Definition prod_uncurry &#123;X Y Z : Type&#125; (f : X → Y → Z) (p : X × Y) : Z := f (fst p) (snd p). 12345678910111213Theorem uncurry_curry : forall (X Y Z : Type) (f : X -&gt; Y -&gt; Z) x y, prod_curry (prod_uncurry f) x y = f x y.Proof. intros. reflexivity. Qed.Theorem curry_uncurry : forall (X Y Z : Type) (f : (X * Y) -&gt; Z) (p : X * Y), prod_uncurry (prod_curry f) p = f p.Proof. intros. destruct p. simpl. reflexivity. Qed. 3. Church Numerals (Advanced) 我们可以将自然数 n 表示为一个函数， 它接受一个函数 f 作为参数并返回迭代了 n 次的 f 1234567891011121314151617181920212223Module Church.Definition cnat := forall X : Type, (X -&gt; X) -&gt; X -&gt; X.(** Let&#x27;s see how to write some numbers with this notation. Iterating a function once should be the same as just applying it. Thus: *)Definition one : cnat := fun (X : Type) (f : X -&gt; X) (x : X) =&gt; f x.(** Similarly, [two] should apply [f] twice to its argument: *)Definition two : cnat := fun (X : Type) (f : X -&gt; X) (x : X) =&gt; f (f x).(** Defining [zero] is somewhat trickier: how can we &quot;apply a function zero times&quot;? The answer is actually simple: just return the argument untouched. *)Definition zero : cnat := fun (X : Type) (f : X -&gt; X) (x : X) =&gt; x. Definition three : cnat := @doit3times. Exercise: 2 stars, advanced (church_scc) 自然数的后继：给定一个邱奇数 n，它的后继 succ n 是一个把它的参数比 n 还多迭代一次的函数。 解析：n作为cnat类型的数据，实际上就是一个函数 123456789101112Definition scc (n : cnat) : cnat := fun (X : Type) (f : X -&gt; X) (x : X) =&gt; n X f (f x).Example scc_1 : scc zero = one.Proof. reflexivity. Qed.Example scc_2 : scc one = two.Proof. reflexivity. Qed.Example scc_3 : scc two = three.Proof. reflexivity. Qed. Exercise: 3 stars, advanced (church_plus) 两邱奇数相加： 12345678910111213Definition plus (n m : cnat) : cnat := fun (X : Type) (f : X -&gt; X) (x : X) =&gt; n X f (m X f x) .Example plus_1 : plus zero one = one.Proof. reflexivity. Qed.Example plus_2 : plus two three = plus three two.Proof. reflexivity. Qed.Example plus_3 : plus (plus two two) three = plus one (plus three three).Proof. reflexivity. Qed. **Exercise: 3 stars, advanced (church_mult) **(不理解) 123456789101112Definition mult (n m : cnat) : cnat := fun (X : Type) (f : X -&gt; X) =&gt; m X (n X f).Example mult_1 : mult one one = one.Proof. reflexivity. Qed.Example mult_2 : mult zero (plus three three) = zero.Proof. reflexivity. Qed.Example mult_3 : mult two three = plus three three.Proof. reflexivity. Qed. Exercise: 3 stars, advanced (church_exp) 乘方： （*’提示’*：多态在这里起到了关键的作用。然而，棘手之处在于选择正确的类型来迭代。 如果你遇到了「Universe inconsistency，全域不一致」错误，请在不同的类型上迭 代。在 cnat 本身上迭代通常会有问题。）","categories":[{"name":"Coq","slug":"Coq","permalink":"https://yanlwsometing.gitee.io/blog/categories/Coq/"}],"tags":[]},{"title":"SF-1-Lists","slug":"SF-1-Lists","date":"2023-07-18T14:44:44.000Z","updated":"2023-12-15T09:08:29.955Z","comments":true,"path":"2023/07/18/SF-1-Lists/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/07/18/SF-1-Lists/","excerpt":"数值序对(Pairs of Numbers)在 Inductive 类型定义中，每个构造子（Constructor）可以有任意多个参数 —— 可以没有（如 true 和 O），可以只有一个（如 S），也可以更多 （如 nybble，以及下文所示）。 1. 定义本文中创建了一种携带两个参数的类型，并为其声明操作函数和记法： 12345678910111213141516171819202122232425262728293031Module NatList.Inductive natprod : Type :=| pair (n1 n2 : nat).Definition fst (p : natprod) : nat := match p with | pair x y =&gt; x end. Definition snd (p : natprod) : nat := match p with | (pair x y) =&gt; y end. Notation &quot;( x , y )&quot; := (pair x y).Definition fst&#x27; (p : natprod) : nat := match p with | (x,y) =&gt; x end.Definition snd&#x27; (p : natprod) : nat := match p with | (x,y) =&gt; y end.Definition swap_pair (p : natprod) : natprod := match p with | (x,y) =&gt; (y,x) end.","text":"数值序对(Pairs of Numbers)在 Inductive 类型定义中，每个构造子（Constructor）可以有任意多个参数 —— 可以没有（如 true 和 O），可以只有一个（如 S），也可以更多 （如 nybble，以及下文所示）。 1. 定义本文中创建了一种携带两个参数的类型，并为其声明操作函数和记法： 12345678910111213141516171819202122232425262728293031Module NatList.Inductive natprod : Type :=| pair (n1 n2 : nat).Definition fst (p : natprod) : nat := match p with | pair x y =&gt; x end. Definition snd (p : natprod) : nat := match p with | (pair x y) =&gt; y end. Notation &quot;( x , y )&quot; := (pair x y).Definition fst&#x27; (p : natprod) : nat := match p with | (x,y) =&gt; x end.Definition snd&#x27; (p : natprod) : nat := match p with | (x,y) =&gt; y end.Definition swap_pair (p : natprod) : natprod := match p with | (x,y) =&gt; (y,x) end. 2. match p vs. match n,m需要注意的是，对于natprod类型的操作函数，不要与两个变量的模式匹配混淆： 12345678910111213(* Can&#x27;t match on a pair with multiple patterns: *) Definition bad_fst (p : natprod) : nat := match p with | x, y =&gt; x end.(* Can&#x27;t match on multiple values with pair patterns: *) Definition bad_minus (n m : nat) : nat := match n, m with | (O , _ ) =&gt; O | (S _ , O ) =&gt; n | (S n&#x27;, S m&#x27;) =&gt; bad_minus n&#x27; m&#x27; end. 3. 序对的简单证明命题：∀ n m, (n,m) &#x3D; (fst (n,m), snd (n,m)) 证明：通过reflexivity简化即可 1234Theorem surjective_pairing&#x27; : forall (n m : nat), (n,m) = (fst (n,m), snd (n,m)).Proof. reflexivity. Qed. 但是，将使用natprod类型再次证明却不行 12345Theorem surjective_pairing_stuck : forall (p : natprod), p = (fst p, snd p).Proof. simpl. (* Doesn&#x27;t reduce anything!！ *)Abort. 我们还需要向 Coq 展示 p 的具体结构，这样 simpl 才能对 fst 和 snd 做模式匹配。通过 destruct 可以达到这个目的。 1234Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p).Proof. intros p. destruct p as [n m]. simpl. reflexivity. Qed. 注意：不同于解构自然数产生两个子目标，destruct 在此只产生 一个子目标。这是因为 natprod 只有一种构造方法。 数值列表(Lists of Numbers)1. 定义列表类型可以如此描述：A list is either the empty list or else a pair of a number and another list. 1234567891011Inductive natlist : Type := | nil | cons (n : nat) (l : natlist). Definition mylist := cons 1 (cons 2 (cons 3 nil)).Notation &quot;x :: l&quot; := (cons x l) (at level 60, right associativity).Notation &quot;[ ]&quot; := nil.Notation &quot;[ x ; .. ; y ]&quot; := (cons x .. (cons y nil) ..). 操作函数 1234567891011121314151617181920212223242526272829303132333435363738(** *** Repeat *)(** Next let&#x27;s look at several functions for constructing and manipulating lists. First, the [repeat] function takes a number [n] and a [count] and returns a list of length [count] in which every element is [n]. *)Fixpoint repeat (n count : nat) : natlist := match count with | O =&gt; nil | S count&#x27; =&gt; n :: (repeat n count&#x27;) end.(** *** Length *)(** The [length] function calculates the length of a list. *)Fixpoint length (l:natlist) : nat := match l with | nil =&gt; O | h :: t =&gt; S (length t) end.(** *** Append *)(** The [app] function concatenates (appends) two lists. *)Fixpoint app (l1 l2 : natlist) : natlist := match l1 with | nil =&gt; l2 | h :: t =&gt; h :: (app t l2) end.Notation &quot;x ++ y&quot; := (app x y) (right associativity, at level 60).Example test_app1: [1;2;3] ++ [4;5] = [1;2;3;4;5].Proof. reflexivity. Qed.Example test_app2: nil ++ [4;5] = [4;5].Proof. reflexivity. Qed.Example test_app3: [1;2;3] ++ nil = [1;2;3].Proof. reflexivity. Qed. 2. 用列表实现口袋（Bag）bag（或者叫 multiset 多重集）类似于集合，只是其中每个元素都能出现不止一次。 口袋的一种可行的表示是列表。 1Definition bag := natlist. 对于其操作的函数 12345678910111213141516171819202122232425262728293031323334353637Fixpoint count (v : nat) (s : bag) : nat := match s with | nil =&gt; 0 | h :: t =&gt; if eqb h v then S (count v t) else count v t end. Definition add (v : nat) (s : bag) : bag := v :: s. Fixpoint member (v : nat) (s : bag) : bool := match s with | nil =&gt; false | h :: t =&gt; if eqb v h then true else member v t end. Fixpoint remove_one (v : nat) (s : bag) : bag := match s with | nil =&gt; nil | h :: t =&gt; if eqb v h then t else h :: remove_one v t end.Fixpoint remove_all (v:nat) (s:bag) : bag := match s with | nil =&gt; nil | h :: t =&gt; if eqb v h then remove_all v t else h :: remove_all v t end.Fixpoint included (s1 : bag) (s2 : bag) : bool := match s1 with | nil =&gt; true | h :: t =&gt; match member h s2 with | true =&gt; included t (remove_one h s2) | false =&gt; false end end. 有关列表的论证(Reasoning About Lists)对于列表的简单事实，可以通过*化简(Simplification)和分类(destruct)*解决 123456789101112Theorem nil_app : forall l:natlist, [] ++ l = l.Proof. reflexivity. Qed.Theorem tl_length_pred : forall l:natlist, pred (length l) = length (tl l).Proof. intros l. destruct l as [| n l&#x27;]. - (* l = nil *) reflexivity. - (* l = cons n l&#x27; *) reflexivity. Qed. 1. 对列表归纳(Induction on Lists)对比对自然数的归纳，归纳证明 natlist 这样的数据类型也是类似的。如果我们有某个命题 P 涉及列表 l，而我们想证明 P 对 ‘一切’ 列表都成立，那么可以像这样推理： 首先，证明当 l 为 nil 时 P l 成立。 然后，证明当 l 为 cons n l’ 时 P l 成立，其中 n 是某个自然数，l’ 是某个更小的列表，假设 P l’ 成立. 12345678910Theorem app_assoc : forall l1 l2 l3 : natlist, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).Proof. intros l1 l2 l3. induction l1 as [| n l1&#x27; IHl1&#x27;]. - (* l1 = nil *) reflexivity. - (* l1 = cons n l1&#x27; *) simpl. rewrite -&gt; IHl1&#x27;. reflexivity. Qed. 形式化证明： ‘定理’：对所有的列表 l1, l2, 和 l3， (l1 ++ l2) ++ l3 &#x3D; l1 ++ (l2 ++ l3)。‘证明’: 通过对 l1 使用归纳法。首先, 假设 l1 &#x3D; []。我们必须证明： ([] ++ l2) ++ l3 &#x3D; [] ++ (l2 ++ l3),这可以通过展开 ++ 的定义得到。然后, 假设 l1 &#x3D; n::l1’，有： (l1’ ++ l2) ++ l3 &#x3D; l1’ ++ (l2 ++ l3)（归纳假设）。我们必须证明： ((n :: l1’) ++ l2) ++ l3 &#x3D; (n :: l1’) ++ (l2 ++ l3).根据 ++ 的定义, 上式等价于： n :: ((l1’ ++ l2) ++ l3) &#x3D; n :: (l1’ ++ (l2 ++ l3)),该式可通过我们的归纳假设立即证得 2. 反转列表(Reversing a List )定义一个列表反转函数 rev： 12345678910Fixpoint rev (l:natlist) : natlist := match l with | nil ⇒ nil | h :: t ⇒ rev t ++ [h] end. Example test_rev1: rev [1;2;3] = [3;2;1].Proof. reflexivity. Qed.Example test_rev2: rev nil = nil.Proof. reflexivity. Qed. 证明反转一个列表不会改变它的长度 1234567891011121314151617181920Theorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2).Proof. (* 课上已完成 *) intros l1 l2. induction l1 as [| n l1&#x27; IHl1&#x27;]. - (* l1 = nil *) reflexivity. - (* l1 = cons *) simpl. rewrite -&gt; IHl1&#x27;. reflexivity. Qed.Theorem rev_length_firsttry : forall l : natlist, length (rev l) = length l.Proof. intros l. induction l as [ | n l&#x27; IHl&#x27;]. - simpl. reflexivity. - simpl. rewrite -&gt; app_length. simpl. rewrite -&gt; IHl&#x27;. rewrite add_comm. reflexivity.Qed. ‘定理’: 对于所有的列表 l，length (rev l) &#x3D; length l。‘证明’: 对 l 进行归纳。首先，假设 l &#x3D; []。我们必须证明 length (rev []) &#x3D; length [],根据 length 和 rev 的定义，上式显然可得。其次，假设 l &#x3D; n::l’，并且 length (rev l’) &#x3D; length l’.我们必须证明 length (rev (n :: l’)) &#x3D; length (n :: l’).根据 rev 的定义，上式来自于 length ((rev l’) ++ [n]) &#x3D; S (length l’)根据之前的引理，此式等同于 length (rev l’) + length [n] &#x3D; S (length l’).根据归纳假设和 length 的定义，上式显然可得。 3. Search在Coq中，你可以使用 Search 命令来搜索与给定的模式匹配的标识符、假设或引理。Search 命令可以帮助你找到与你的目标或问题相关的定义、引理或定理。 Search 命令的语法如下：Search pattern.。其中，pattern 是你要搜索的模式。模式可以是标识符、表达式、引理语句等。 以下是几个示例，展示了 Search 命令的使用方法： 搜索某个标识符： 1Search plus. 这会搜索包含关键词 “plus” 的标识符，如 Nat.add、Nat.add_0_r 等（add涉及到plus函数）。 搜索某个已知的引理或定理： 1Search (_ + _ = _ + _). 这会搜索形式类似于 _ + _ = _ + _ 的引理或定理，例如 Nat.add_comm、Nat.add_assoc 等。 搜索特定类型的假设： 1Search (forall (_ : nat), _ = _ -&gt; _ = _). 这会搜索具有形式 forall (_ : nat), _ = _ -&gt; _ = _ 的假设，其中 _ 用于匹配任意的项。 在某个模块中搜索 1Search (_ + _ = _ + _) inside Induction. 需要注意的是，Search 命令会搜索当前环境中可见的定义和引理。如果你在证明中使用了 Require 或 Import 命令导入了其他模块，那么 Search 命令也会搜索这些导入的模块中的定义和引理。 Options 可选类型假设我们想要写一个返回某个列表中第 n 个元素的函数。如果我们为它赋予类型 nat → natlist → nat，那么当列表太短时我们仍须返回某个数… 12345678Fixpoint nth_bad (l:natlist) (n:nat) : nat := match l with | nil =&gt; 42 | a :: l&#x27; =&gt; match n with | 0 =&gt; a | S n&#x27; =&gt; nth_bad l&#x27; n&#x27; end end. 但是，这样会产生混淆，因此需要改变 nth_bad 的返回类型，使其包含一个错误值作为可能的结果。 我们将此类型命名为 natoption 123Inductive natoption : Type := | Some (n : nat) | None. 偏映射 （Partial Maps）这是一个简单的 ‘偏映射’ 数据类型，它类似于大多数编程语言中的映射或字典数据结构。 1234567Inductive id : Type := | Id (n : nat). Inductive partial_map : Type := | empty | record (i : id) (v : nat) (m : partial_map). Exercises Exercise: 3 stars, advanced (alternate)：设计一个函数，将两个列表交替合并 1234567891011121314151617181920212223Fixpoint alternate (l1 l2 : natlist) : natlist := match l1 with | nil =&gt; l2 | h1 :: t1 =&gt; h1 :: match l2 with | nil =&gt; t1 | h2 :: t2 =&gt; h2 :: alternate t1 t2 end end. Example test_alternate1: alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6]. (* FILL IN HERE *) Admitted.Example test_alternate2: alternate [1] [4;5;6] = [1;4;5;6]. (* FILL IN HERE *) Admitted.Example test_alternate3: alternate [1;2;3] [4] = [1;4;2;3]. (* FILL IN HERE *) Admitted.Example test_alternate4: alternate [] [20;30] = [20;30]. (* FILL IN HERE *) Admitted.","categories":[{"name":"Coq","slug":"Coq","permalink":"https://yanlwsometing.gitee.io/blog/categories/Coq/"}],"tags":[]},{"title":"Linux（二）","slug":"Linux（二）","date":"2023-06-30T10:52:12.000Z","updated":"2023-12-15T08:53:06.884Z","comments":true,"path":"2023/06/30/Linux（二）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/30/Linux%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Invalid option: -30… Suggested alternative: ‘-30’现象： 解决方案： 123VERILATOR_CFLAGS += -MMD --build -cc -03 \\ --x-assign fast --x-initial fast --noassert","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/tags/Linux/"}]},{"title":"Linux（一）","slug":"Linux（一）","date":"2023-06-12T02:10:22.000Z","updated":"2023-12-15T09:07:10.851Z","comments":true,"path":"2023/06/12/Linux（一）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/12/Linux%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"本篇主要讲解Linux的工具及其基本的使用 安装中文输入法 安装拼音输入法： sudo apt-get install ibus-pinyin 重启系统： sudo reboot 启动拼音输入法： ibus-daemon -d 设置拼音输入法： im-config 然后在弹出的窗口中，选择“IBus”，点击“OK”，重启系统即可。 之后在setting -&gt; keyboard，添加Chinese(Pinyin)","text":"本篇主要讲解Linux的工具及其基本的使用 安装中文输入法 安装拼音输入法： sudo apt-get install ibus-pinyin 重启系统： sudo reboot 启动拼音输入法： ibus-daemon -d 设置拼音输入法： im-config 然后在弹出的窗口中，选择“IBus”，点击“OK”，重启系统即可。 之后在setting -&gt; keyboard，添加Chinese(Pinyin) manmanual page主要包含以下的小节: NAME - 命令名 SYNOPSIS - 使用方法大纲 CONFIGURATION - 配置 DESCRIPTION - 功能说明 OPTIONS - 可选参数说明 EXIT STATUS - 退出状态, 这是一个返回给父进程的值 RETURN VALUE - 返回值 ERRORS - 可能出现的错误类型 ENVIRONMENT - 环境变量 FILES - 相关配置文件 VERSIONS - 版本 CONFORMING TO - 符合的规范 NOTES - 使用注意事项 BUGS - 已经发现的bug EXAMPLE - 一些例子 AUTHORS - 作者 SEE ALSO - 功能或操作对象相近的其它命令 vimvim是一种文本编辑器，它是Unix和类Unix系统中最流行的编辑器之一。Vim是Vi编辑器的改进版本，它在可视化模式、功能扩展和用户界面方面做了大量改进。 1. 安装1$ sudo apt install vim 2. 配置 We first make a copy of it to the home directory by cp command: 1$ cp /etc/vim/vimrc ~/.vimrc And switch to the home directory if you are not under it yet: 1$ cd ~ If you use ls to list files, you will not see the .vimrc you just copied. This is because a file whose name starts with a . is a hidden file in GNU&#x2F;Linux. To show hidden files, use ls with -a option: 1$ ls -a Then open .vimrc using vim: 1$ vim .vimrc modify the .vimrc file as following: 12345678910111213141516171819202122232425262728--- before modification+++ after modification@@ -21,3 +21,3 @@ &quot; If using a dark background within the editing area and syntax highlighting &quot; turn on this option as well-&quot;set background=dark+set background=dark@@ -31,5 +31,5 @@ &quot; Uncomment the following to have Vim load indentation rules and plugins &quot; according to the detected filetype.-&quot;filetype plugin indent on+filetype plugin indent on@@ -37,10 +37,10 @@ &quot; The following are commented out as they cause vim to behave a lot &quot; differently from regular Vi. They are highly recommended though. &quot;set showcmd &quot; Show (partial) command in status line.-&quot;set showmatch &quot; Show matching brackets.-&quot;set ignorecase &quot; Do case insensitive matching-&quot;set smartcase &quot; Do smart case matching-&quot;set incsearch &quot; Incremental search+set showmatch &quot; Show matching brackets.+set ignorecase &quot; Do case insensitive matching+set smartcase &quot; Do smart case matching+set incsearch &quot; Incremental search &quot;set autowrite &quot; Automatically save before commands like :next and :make-&quot;set hidden &quot; Hide buffers when they are abandoned+set hidden &quot; Hide buffers when they are abandoned &quot;set mouse=a &quot; Enable mouse usage (all modes) 123456789101112131415161718192021222324252627setlocal noswapfile &quot; 不要生成swap文件set bufhidden=hide &quot; 当buffer被丢弃的时候隐藏它colorscheme evening &quot; 设定配色方案set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=2 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 2set softtabstop=2 &quot; 使得按退格键时可以一次删掉 2 个空格set tabstop=2 &quot; 设定 tab 长度为 2set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录set backupcopy=yes &quot; 设置备份时的行为为覆盖set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start &quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ Ln\\ %l,\\ Col\\ %c/%L%) &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为 1 3. 使用 Issue the vimtutor command in terminal. This will launch a tutorial for vim. This way is recommended, since you can read the tutorial and practice at the same time. 12345678910111213141516Lesson 1 SUMMARY 1. The cursor is moved using either the arrow keys or the hjkl keys. h (left) j (down) k (up) l (right) 2. To start Vim from the shell prompt type: vim FILENAME &lt;ENTER&gt; 3. To exit Vim type: &lt;ESC&gt; :q! &lt;ENTER&gt; to trash all changes. OR type: &lt;ESC&gt; :wq &lt;ENTER&gt; to save the changes. 4. To delete the character at the cursor type: x 5. To insert or append text type: i type inserted text &lt;ESC&gt; insert before the cursor A type appended text &lt;ESC&gt; append after the line 12345678910111213141516171819202122 Lesson 2 SUMMARY1. To delete from the cursor up to the next word type: dw2. To delete from the cursor up to the end of the word type: de3. To delete from the cursor to the end of a line type: d$4. To delete a whole line type: dd5. To repeat a motion prepend it with a number: 2w6. The format for a change command is: operator [number] motion where: operator - is what to do, such as d for delete [number] - is an optional count to repeat the motion motion - moves over the text to operate on, such as w (word), e (end of word), $ (end of the line), etc.7. To move to the start of the line use a zero: 0 8. To undo previous actions, type: u (lowercase u) To undo all the changes on a line, type: U (capital U) To undo the undo&#x27;s, type: CTRL-R 1234567891011121314151617181920 Lesson 3 SUMMARY 1. To put back text that has just been deleted, type p . This puts the deleted text AFTER the cursor (if a line was deleted it will go on the line below the cursor). 2. To replace the character under the cursor, type r and then the character you want to have there. 3. The change operator allows you to change from the cursor to where the motion takes you. eg. Type ce to change from the cursor to the end of the word, c$ to change to the end of a line. 4. The format for change is: c [number] motionNow go on to the next lesson. 12345678910111213141516171819202122Lesson 4 SUMMARY 1. CTRL-G displays your location in the file and the file status. G moves to the end of the file. number G moves to that line number. gg moves to the first line. 2. Typing / followed by a phrase searches FORWARD for the phrase. Typing ? followed by a phrase searches BACKWARD for the phrase. After a search type n to find the next occurrence in the same direction or N to search in the opposite direction. CTRL-O takes you back to older positions, CTRL-I to newer positions. 3. Typing % while the cursor is on a (,),[,],&#123;, or &#125; goes to its match. 4. To substitute new for the first old in a line type :s/old/new To substitute new for all &#x27;old&#x27;s on a line type :s/old/new/g To substitute phrases between two line #&#x27;s type :#,#s/old/new/g To substitute all occurrences in the file type :%s/old/new/g To ask for confirmation each time add &#x27;c&#x27; :%s/old/new/gc 12345678910111213141516171819202122Lesson 5 SUMMARY 1. :!command executes an external command. Some useful examples are: (Windows) (Unix) :!dir :!ls - shows a directory listing. :!del FILENAME :!rm FILENAME - removes file FILENAME. 2. :w FILENAME writes the current Vim file to disk with name FILENAME. 3. v motion :w FILENAME saves the Visually selected lines in file FILENAME. 4. :r FILENAME retrieves disk file FILENAME and puts it below the cursor position. 5. :r !dir reads the output of the dir command and puts it below the cursor position. gitGit类似于游戏的存档工具，防止你需要重复过剧情。它是一个流行的版本控制系统，它广泛应用于软件开发中。Git可以帮助开发者记录并追踪他们的代码修改、协同开发、管理版本和分支，以及将代码推送到不同的远程代码仓库中存储。 1. 安装1$ sudo apt install vim 2. 配置1234$ git config --global user.name &quot;Zhang San&quot; # your name$ git config --global user.email &quot;zhangsan@foo.com&quot; # your email$ git config --global core.editor vim # your favourite editor$ git config --global color.ui true 管理多个帐户 - GitHub 文档 新增 SSH 密钥到 GitHub 帐户 - GitHub 文档 3. 使用存档信息： 123456789$ git clone # 下载框架代码,里面已经包含一些 git 记录$ git init # 在实验/项目中使用 git,需要初始化$ git log # 查看目前为止所有的存档$ git status # 可以得知, 与当前存档相比, 哪些文件发生了变化$ git diff$ git add file.c # 将文件加入跟踪列表$ git add -A # 一次添加所有未被跟踪的文件$ vim .gitignore # 编辑 .gitignore 文件, # 在里面给出需要被 git 忽略的文件和文件类型 存读档： 12$ git commit # 存档$ git reset --hard b87c # 读档（这意为着你不能随便回到&quot;将来&quot;了） 第三视点： 1234$ git branch # 查看所有分支$ git checkout b87c # 将处于一个虚构的分支中,查看 b87c 存档的内容$ git checkout 分支名 # 切换到其它分支$ git checkout -B 分支名 # 对代码的内容进行修改之后存档 tmuxtmux是终端多路复用器。 它让您在一个终端中的多个程序之间轻松切换，分离它们（它们在后台运行）并将其重新连接到不同的终端。 12345678910111213141516171819202122232425262728293031323334# 查看所有会话tmux ls# 新建一个名为earor的会话，下面会出现状态栏tmux new -s earor# 当前窗口名为bash，修改为aeot，此时状态栏左侧显示[earor] 0:aeot* ，0代表第0个窗口tmux rename-window aeot# 先用快捷键将aeot窗口分成上下两个窗格，快捷键忽略左右两个反引号``ctrl b &quot;`# 此时光标在下面的窗格，用快捷键将光标移动到上面`ctrl b 上方向键`# 继续上部窗窗格分成左右两栏，左边的跑训练任务，右边的显示GPU信息`ctrl b %`# 右上角GPU信息不需要太大，用快捷键调小一些，第二次按ctrl不松开，可以连续点按方向键`ctrl b ctrl 右方向键``ctrl b ctrl 上方向键`# 创建第二个pugan窗口tmux new-window -n pugan# 用快捷键切换window窗口切换到最后一个会继续循环，从而展示第一个## 向前`ctrl b p`## 向后`ctrl b n```# 然后直接关掉终端窗口或者断网，或者键入如下命令或快捷键，会话状态会由attached变成detachedtmux detach `ctrl b d`# 重新连接earor会话tmux attach -t earor# 如果某个回话中的程序卡住了，可以杀死sessiontmux kill-session -t earor makemake是一个在软件开发中所使用的工具程序（Utility software），经由读取“makefile”的文件以自动化建构软件。 gdbGDB, The GNU Debugger, By Example - Cprogramming.com GNU调试器（英语：GNU Debugger，缩写：GDB），是GNU软件系统中的标准调试器，此外GDB也是个具有移携性的调试器，经过移携需求的调修与重新编译，如今许多的类UNIX操作系统上都可以使用GDB，而现有GDB所能支持调试的编程语言有C、C++、Pascal以及FORTRAN。 GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC）是GNU计划制作的一种优化编译器，支持各种编程语言、操作系统、计算机系统结构。该编译器是以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，还是GNU工具链的主要组成部分之一。 Tmuxverilator待整理 makefile gdb","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/categories/Linux/"}],"tags":[{"name":"Linux工具","slug":"Linux工具","permalink":"https://yanlwsometing.gitee.io/blog/tags/Linux%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux入门","slug":"Linux入门","date":"2023-06-11T02:55:35.000Z","updated":"2024-04-14T06:57:40.806Z","comments":true,"path":"2023/06/11/Linux入门/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/11/Linux%E5%85%A5%E9%97%A8/","excerpt":"对比windows的优点 Linux提供更多的系统工具和命令行，能够快速解决问题 例如：比较两个文件是否完全相同 1234567# Linuxvimdiff f1 f2 # 文本文件diff f1 f2 # 非文本文件md5sum f1 f2 # 大文件# Windows# 安装md5工具 复杂问题，通过将小工具组合，解决效率高效 例如：列出一个c语言项目中所有被包含过的头文件 12# Linuxfind .-name &quot;*.[ch]&quot; | xargs grep &quot;#include&quot; | sort | uniq ”面向程序员“，开源、高效、适应环境多","text":"对比windows的优点 Linux提供更多的系统工具和命令行，能够快速解决问题 例如：比较两个文件是否完全相同 1234567# Linuxvimdiff f1 f2 # 文本文件diff f1 f2 # 非文本文件md5sum f1 f2 # 大文件# Windows# 安装md5工具 复杂问题，通过将小工具组合，解决效率高效 例如：列出一个c语言项目中所有被包含过的头文件 12# Linuxfind .-name &quot;*.[ch]&quot; | xargs grep &quot;#include&quot; | sort | uniq ”面向程序员“，开源、高效、适应环境多 认识Linux1. 命令格式1命令 参数1 参数2 ... 2. 不区分系统盘 3. 丰富的工具包搜索：Ubuntu – Ubuntu Packages Search 了解工具的运行（&#x3D;打开黑盒）： source：看源码，细致但较繁琐 trace：看踪迹，不全面但易理解 踪迹工具strace ：system call trace，记录程序运行过程中的系统调用信息 12345678910# ls 如何运行strace lsstrance ls -l# ls 命令如何被寻找strace -f bash -c &quot;ls&quot;# 用户如何与man 交互strace -o strace.log -f man lstail -f strace.log # 在另一个窗口执行 4. shell方便的功能 通过Tab键自动补全 通过上下方向键检索历史命令 可以通过A-f和A-b按键来按单词移动光标 更多快捷键可以阅读man readline 通过history命令查看历史命令 通过!n(n为历史命令的编号)再次执行命令 通过!xxx再次执行以xxx开头的最近一条命令 通过cd -返回上一个工作目录 通配符*(任意长度的任意字符串), ?(任意一个字符)和[...](集合中的任意一个字符) 括号扩展&#123;...&#125; (例: echo Hello-&#123;a,bb,ccc&#125;-&#123;1,2&#125;!) alias 为常用命令设置别名，alias ls=&quot;ls --color&quot;。也可以写入~/.bashrc，打开终端时生效 5. 正则表达式一般配合grep, awk, sed, vim等工具使用 6. 任务管理 最小化(在后台运行) : C-Z+bg 或运行命令时通过末尾添加&amp;指定后台运行 任务栏 : jobs 最大化 : fg 关闭 kill 一般通过kill -9 进程号强行关闭 任务管理器 - ps aux, top, htop 7. 输入输出重定向Linux上的程序在运行时默认打开了3个文件, 通过 “文件描述符”来编号: 0号文件 - 标准输入(默认为当前终端) 1号文件 - 标准输出(默认为当前终端) 2号文件 - 标准错误(默认为当前终端) 可通过lsof -p 进程号来查看打开的文件 8. 管道：工具组合123+-------+ stdout +------+ stdin +-------+| prog1 | --------&gt; | pipe | -------&gt; | prog2 |+-------+ +------+ +-------+ 管道 &#x3D; 一个用于连接程序间输入输出的缓冲区。 例如上图，prog1和prog2为两个小工具，prog2需要prog1的输出，那么就需要当prog1将输出数据填入pipe中，prog2再进行读入。 xargs: 一个特殊的命令, 可以将标准输入转变为命令的参数 青春版直播时钟 12watch -t -n 1 &quot;echo -n &#x27;第五期一生一芯 | 周六 19:00~21:00 | &#x27;; \\ date; echo &#x27;课程主页 https://ysyx.oscc.cc/docs/&#x27;&quot; 无人值守重试操作 12while ! git push origin HEAD; do echo &quot;retry&quot;; donewhile [[ `seq 1 10 | shuf | head -n 1` != &quot;1&quot; ]]; do echo &quot;retry&quot;; done 自制CPU主频监视器 1watch -n 1 &quot;cat /proc/cpuinfo | grep MHz | awk &#x27;&#123;print \\$1 NR \\$3 \\$4 \\$2&#125;&#x27;&quot; 打包特定文件并上传到远端 1find . -name &quot;*.pdf&quot; | xargs tar cj | ssh yzh@192.168.1.1 &#x27;cd ysyx; &gt; pdf.tar.bz2&#x27; 9. 脚本学会Linux以下工具覆盖了程序员绝大部分的需求 123456文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar，echo文件检索 - cat, more, less, head, tail, file, find输入输出控制 - 重定向, 管道, tee, xargs文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr正则表达式任务管理 - jobs, ps, top, kill, free, lsof 先进的工具 python vs. 计算器 awesome系列 thefuck - 命令行智能纠错工具 如果记不住 尝试-h, --help等选项查看帮助信息 man 更多工具的介绍 The Missing Semester of Your CS Education The Art of Command Line 1. RTFM学习Linux就要学会查阅Linux手册 man 查阅命令&#x2F;库函数&#x2F;系统文件等内容的手册 man man - 学习如何RTFM man ls - 查看如何使用ls命令 man 3 printf - 学习如何使用库函数printf man -k xxx - 检索含有关键字含有xxx的命令 2. STFW使用搜索引擎帮助你找到解决方案 例如：终端实现分屏 搜”Linux 分屏“ -&gt; 得知工具tmux apt-get install tmux 搜 “tmux 教程” -&gt; 阅读教程学习tmux的使用 有的地方还不太明白-&gt; man tmux -&gt; 解决 命令小记 登录root权限：su su: Authentication failure ：sudo passwd root 强制删除目录：rm -r 文件名 强制删除目录及文件：rm -rf 文件名 检查安装包的版本号：dpkg -l | grep &lt;包名&gt; 搜索包的可用版本：apt-cache policy &lt;包名&gt; 安装指定版本：sudo apt install libpython3.10-minimal=3.10.4-3 更新软件包列表：sudo apt update 安装方案：aptitude install 包名 创建软连接：ln -s [目标文件或目录] [链接名称] 删除软连接：rm [连接名称] 小结Linux比windows有众多的好处，它的优点值得我们去使用。也许在使用中会有很多不适，这就如同初碰智能手机一样，反正不会坏，多尝试就好了。 “一生一芯”的系列课程让我感触很多，其中很多的知识我都曾经学过，并且成绩不错（卷面成绩），可是事到如今，我依旧感觉基础不牢，也许就是因为没有坚持下来，没有做到”好记性不如烂笔头“。如今我已步入研究生的行列，得此良机，我想重新学习，重新温故，不求速成，但求融会贯通。 参考资料[Linux入门教程 第五期“一生一芯”计划 - P2]_哔哩哔哩_bilibili","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/tags/Linux/"}]},{"title":"认真的提问","slug":"认真的提问","date":"2023-06-10T12:29:23.000Z","updated":"2023-12-15T09:00:11.588Z","comments":true,"path":"2023/06/10/认真的提问/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/10/%E8%AE%A4%E7%9C%9F%E7%9A%84%E6%8F%90%E9%97%AE/","excerpt":"当你认真地做一件事情的时候，例如练书法，你的什么做法会让你感受到自己的认真呢？可能是练之前洗洗手，这样以免弄脏练字纸；可能是回顾一下自己的作品，这样可以温故知新。 从这里我们可以得出一个结论了，认真的意义在于，避免我们步入尴尬的境地，提高我们做事的效率。 认真地提问，也应该如此。 阅读自提问的智慧 和 别问傻x问题","text":"当你认真地做一件事情的时候，例如练书法，你的什么做法会让你感受到自己的认真呢？可能是练之前洗洗手，这样以免弄脏练字纸；可能是回顾一下自己的作品，这样可以温故知新。 从这里我们可以得出一个结论了，认真的意义在于，避免我们步入尴尬的境地，提高我们做事的效率。 认真地提问，也应该如此。 阅读自提问的智慧 和 别问傻x问题 找到合适的提问对象当有人对你说RTFM（Read The Fucking Manual） 或者 STFW（Search The Fucking Web），可以看到的是你提问对象找错了。 下面列出一些常用的stackflow exchange网址： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题 IRC 频道 本地的用户群组（user group） STFW警告!!! - 远离百度的毒害 搜索引擎 百科 问答网站 提高效率 www.google.com en.wikipedia.org stackoverflow.com 浪费生命 www.baidu.com baike.baidu.com zhidao.baidu.com bbs.csdn.net 准备好你的问题大佬都喜爱有挑战性的问题，或者能激发他们思维的好问题，但是对那些不愿思考、或者在发问前不做他们该做的事的人，他们会毫不介意表现自己的蔑视。 下面是一些总结： 标题（目标-差异 不要猜测，阐述问题，包括（你的问题或 Bug 的症状、描述问题发生的环境、你是怎样去研究和理解这个问题、为确定问题而采取的诊断步骤、尽可能地提供一个可以重现这个问题的可控环境的方法、描述最近做过什么可能相关的硬件或软件变更 描述目标 聪明的问题 X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下… English is not my native language; please excuse typing errors. I am familiar with the technical terms, but some slang expressions and idioms are difficult for me. 我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 不要让问题成为一个”弃婴“当你的问题得到解决后，若是在论坛中提出，请给他加一个简单的说明，若是自己独立解决，也请在日志中留下自己的记号。这些都能证明你是一个负责任的人，不会给环境留下更多的垃圾。 当有人求教你曾经遇到过的问题，如果你决定回答，就请给出好的答案。你是一个负责任的人，既然想帮助别人，可不要中途放弃哦 RTFSC （Read the f**king source code） 小结提问，高效的提问，认真的提问，无非是为了问题能够快速的解决。问题的解决需要众人的努力，这其中也包括你。让回答者更好地理解并精准地解答问题，这是提问者的义务，也是提问者的责任。","categories":[{"name":"其他","slug":"其他","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"节点搭建（一）","slug":"节点搭建（一）","date":"2023-06-03T13:26:10.000Z","updated":"2023-12-22T08:18:09.739Z","comments":true,"path":"2023/06/03/节点搭建（一）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/03/%E8%8A%82%E7%82%B9%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"前言出于对个人信息的保护，我们需要对数据进行加密，防止别人直接探测我们的访问意图。因此，本人学习了计算机网络来进行代理节点的搭建工作。这是一篇纯理论的笔记，供自己参考。 DNS协议，即域名系统协议，用于域名与IP地址进行映射。当在浏览器输入网址之后，浏览器会向DNS服务器发送请求，获取相对应的IP地址。","text":"前言出于对个人信息的保护，我们需要对数据进行加密，防止别人直接探测我们的访问意图。因此，本人学习了计算机网络来进行代理节点的搭建工作。这是一篇纯理论的笔记，供自己参考。 DNS协议，即域名系统协议，用于域名与IP地址进行映射。当在浏览器输入网址之后，浏览器会向DNS服务器发送请求，获取相对应的IP地址。 节点搭建1. 思路 需要通过ss将数据进行加密，再由节点代理访问，但是由于重放攻击，导致相应端口会被攻击屏蔽，所以需要v2ray-plugin。 系统代理监听浏览器请求，并在本地对请求进行加密，plugin对其进行伪装后，再进行转发。 2. 过程 获得虚拟专用服务器 虚拟专用服务器（Virtual Private Server，简称VPS）技术，是将一台服务器分割成多个虚拟专享服务器的优质服务。实现VPS的技术分为容器技术，和虚拟化技术 。在容器或虚拟机中，每个VPS都可选配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验 便宜，皮实 SSH工具 SSH客户端 (hostbuf.com) 购买一个vps，获得服务器的IP地址和密码， 下载finalshell，对服务器进行远程连接 构建ss服务 1234567891011121314151617181920212223# 安装ss服务apt isntall shadowsocks-libev# 查看ss服务运行状态systemctl status shadowsocks-libev.service# 更改ss配置vim /etc/shadowsocks-libev/config.json# 重启shadowsockssystemctl restart shadowsocks-libev.service# 开放主动监听的接口utf allow xx# 删除接口ufw delete allow xx# 拒绝接口ufw deny xx# 查看状态ufw status 添加v2ray-plugin 重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性 端口扫描 - 站长工具 (chinaz.com) iP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com) 1234567891011# 安装 v2ray-pluginapt install shadowsocks-v2ray-plugin# 查看安装包解压的内容dpkg -L shadowsocks-v2ray-plugin# 修改config.json&quot;plugin&quot;: &quot;ss-v2ray-plugin&quot;&quot;plugin_opts&quot;: &quot;server&quot;# 重启shadowsocks Release v1.3.2 · shadowsocks&#x2F;v2ray-plugin (github.com) 小结由于ss协议发送的数据是无规则的字节流，因此在平平无奇的网络中显得特别突出，就会遭到重放攻击。plugin将字节流处理成http流量，但是还是存在被攻击的可能。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"文献结构","slug":"文献结构","date":"2023-06-01T08:39:29.000Z","updated":"2023-12-15T08:59:21.948Z","comments":true,"path":"2023/06/01/文献结构/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/06/01/%E6%96%87%E7%8C%AE%E7%BB%93%E6%9E%84/","excerpt":"本文为一篇学习笔记，其中涵盖大量的他人的经验，知识来源：【科研文献阅读】SCI顶刊学长用西红柿炒鸡蛋告诉你文献是什么样的 | 研究生必须掌握的文献结构 | 高效阅读方法基础 | 论文写作基础 | 撰写综述必备的阅读技_哔哩哔哩_bilibili 一篇文章大致可以分为引言，研究工作和总结三大部分，以下为对这三个部分的分析。","text":"本文为一篇学习笔记，其中涵盖大量的他人的经验，知识来源：【科研文献阅读】SCI顶刊学长用西红柿炒鸡蛋告诉你文献是什么样的 | 研究生必须掌握的文献结构 | 高效阅读方法基础 | 论文写作基础 | 撰写综述必备的阅读技_哔哩哔哩_bilibili 一篇文章大致可以分为引言，研究工作和总结三大部分，以下为对这三个部分的分析。 引言部分大背景说明研究的重要性，用于介绍该研究项目对人类的作用，在科学界、专业领域以及世界的地位，总之是大方向的角度谈背景 研究现状谈一谈研究的历史过程，国内外的主攻方向有哪些，成果有什么，一些正在尝试的新流派 引出本文的研究内容因为某些因素，出于一些目的，在某些情况的限制下，出现了怎么样的问题。其他实验室是怎么做的，简要介绍我们的方法，并介绍方法的优势 研究工作部分研究的准备工作 对引言中引出的问题进行数学建模，将问题转化为专业语言 提出衡量指标 对读懂文章所需要的基础理论知识进行说明 研究方法数学证明等 实验设计 介绍如何设计实验 实验平台怎么设计、数据怎么采集 怎么控制无关变量 怎么获取指标数据 结果分析 得到了什么指标 通过分析指标、对比其他方法，体现我们方法的优势 得出结论：在什么情况下、我们的方法具有一定的优势 总结部分本文针对什么问题进行研究，使用了什么方法，得到了什么结果，最后尝试分析不足，未来可以探索的点 阅读方法 快速浏览：标题、摘要、结论 速读：摘抄研究背景、摘抄论文的贡献、阅读研究成果、研究的相近程度、研究成果的探讨","categories":[{"name":"其他","slug":"其他","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文献","slug":"文献","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E6%96%87%E7%8C%AE/"}]},{"title":"快捷键使用","slug":"快捷键使用","date":"2023-05-27T07:35:19.000Z","updated":"2023-12-15T08:58:56.669Z","comments":true,"path":"2023/05/27/快捷键使用/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/05/27/%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8/","excerpt":"pycharm 快捷键组合 功能 【alt + shift +↑↓】 整行复制 【ctrl + shift + enter】 换行 【Ctrl+[】 定位到行最前面 【Ctrl+]】 定位到行最后面,用来在括号内输入完成后跳到括号后面,不用去按方向键 【Ctrl+Shift+A】 查找操作 【CTRL+D】 复制文本光标所在行 【Ctrl+Y】 删除当前行 【Alt+Enter】 输入代码显示意图 【Ctrl+Alt+L】 格式化所选代码段 【shift+f10】 执行 【Ctrl+空格】 如果按【Ctrl+空格】尝试基本补全不行 【Ctrl+Shift+空格】 使用【Ctrl+Shift+空格】调用智能补全","text":"pycharm 快捷键组合 功能 【alt + shift +↑↓】 整行复制 【ctrl + shift + enter】 换行 【Ctrl+[】 定位到行最前面 【Ctrl+]】 定位到行最后面,用来在括号内输入完成后跳到括号后面,不用去按方向键 【Ctrl+Shift+A】 查找操作 【CTRL+D】 复制文本光标所在行 【Ctrl+Y】 删除当前行 【Alt+Enter】 输入代码显示意图 【Ctrl+Alt+L】 格式化所选代码段 【shift+f10】 执行 【Ctrl+空格】 如果按【Ctrl+空格】尝试基本补全不行 【Ctrl+Shift+空格】 使用【Ctrl+Shift+空格】调用智能补全","categories":[{"name":"其他","slug":"其他","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"OCaml初识","slug":"OCaml初识","date":"2023-05-18T09:51:49.000Z","updated":"2023-12-15T08:56:34.741Z","comments":true,"path":"2023/05/18/OCaml初识/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/05/18/OCaml%E5%88%9D%E8%AF%86/","excerpt":"OCaml安装（win10）这里我只推荐安装虚拟机Ubuntu，都是血泪史，为了搞这个环境我废了两天:sob:。 如果你不想看我的吐槽小作文，可以直接跳到Ubuntu 注意：建议别搜索教程(我的除外:yum:)，先看官方文档：Get Up and Running With OCaml · OCaml Tutorials","text":"OCaml安装（win10）这里我只推荐安装虚拟机Ubuntu，都是血泪史，为了搞这个环境我废了两天:sob:。 如果你不想看我的吐槽小作文，可以直接跳到Ubuntu 注意：建议别搜索教程(我的除外:yum:)，先看官方文档：Get Up and Running With OCaml · OCaml Tutorials 1 Windows当你百度ocaml安装时，你会将那仅有的几篇博客当作你的救星。如果此时你觉得只要跟着作者思路，ocaml安装只是洒洒水而已，恭喜你，又一个大怨种出世了。 我们先不说ocaml对windows版本支持的情况如何，也不说你会不会WSL2以及相应的工具，就单单就是这图像下载器就会明白青春的可贵。 重复的安装，重复的失败。6个小时，但最后我选择了放弃。 1.1 WSL2+VScode在官方文档OCaml on Windows · OCaml Tutorials 中，明确提到 Only to run, not develop, applications, use Docker or WSL2 如果仅仅是运行，可以使用wsl2。wsl2安装：安装 WSL | Microsoft Learn 但我觉得最简单的方式还是从Microsoft Store中搜索wsl直接安装，从结果看即是这种旧版 WSL 的手动安装步骤 | Microsoft Learn。 （后续：安装wsl2之后，就可以对Ocaml进行安装使用了，其实也挺方便） 1.2 Cygwin这是我所在的课题组导师推荐的使用方式，优势方面我还不是很清楚，都是linux，安装相对应的包 Cygwin 2 CentOS如果windows版本的安装过程提醒了我要挑软柿子捏，那么CentOS版本则教会了我一定得先看官方文档:sob: 注意：CentOS版官方没有提供相关包，这只是吐槽篇，因此可以直接跳过 安装虚拟机VMware ：下载 VMware Workstation Pro | CN 【记得搜个码白嫖哦】 下载CentOS镜像：CentOS镜像| 清华大学开源软件镜像站 | 创建一个虚拟机并安装：VMware虚拟机之Linux虚拟机安装_哔哩哔哩_bilibili 更新yum源 当你完成了上面的所有，恭喜你，白费功夫，因为官网说了，没有包！ 痛，太痛了。。。 3 Ubuntu使用VMware创建虚拟机并安装Ubuntu镜像（中间记得选Ubuntu 64-bit），然后根据上面的文档来做， Ubuntu镜像：Ubuntu 22.04 镜像命名格式：ubuntu - 版本号 - 镜像类型 - 设备位数 - 文件后缀 终端执行如下指令： 12345678910$ sudo apt-get install opam # 安装ocaml包管理器$ opam init # 初始化 $ eval $(opam env) # 更新ocaml环境$ opam switch create 4.14.0 #更换版本$ eval $(opam env)$ ocaml -version #检查版本号 注意： 或者跟着一位前辈一步一步来01-Ocaml环境搭建_哔哩哔哩_bilibili 中间前辈插入了启动脚本，命令应该为vim ~/.bashrc 版本更换命令如上 OCaml初始1 编程范式对比 过程式 函数式 面向对象 直观表现 语句的连续执行 各种函数的组合，定义函数，调用函数 对象之间交互 关键词 状态改变 纯函数概念 封装、继承、多态 重复方式 循环 递归 循环 纯函数：只做输入输出的改变，不做副改变 12int f (int a) &#123;return a+1;&#125; # 纯函数int g (int a) &#123;int b=a; return a;&#125; 2 特点 多范式语言。 自动管理内存。 静态类型。 在执行之前检测表达式类型，不正确不执行 多态参数。 可以自己定义联合类型。user type 模块化。 3 交互特点 命令行对话式交互 编译器执行时内部主要的过程有： 读取每一句代码且检查是否有格式错误 检查是否有类型错误 执行语句 显示结果","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"ocaml安装","slug":"ocaml安装","permalink":"https://yanlwsometing.gitee.io/blog/tags/ocaml%E5%AE%89%E8%A3%85/"},{"name":"VMware","slug":"VMware","permalink":"https://yanlwsometing.gitee.io/blog/tags/VMware/"},{"name":"wsl2","slug":"wsl2","permalink":"https://yanlwsometing.gitee.io/blog/tags/wsl2/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"数据结构","slug":"数据结构","date":"2023-05-14T09:24:17.000Z","updated":"2023-06-04T07:51:05.418Z","comments":true,"path":"2023/05/14/数据结构/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"这是数据结构篇。 大学毕业之后，我一直想找机会将所学的基础知识总结一下，这样既能够强化记忆，也有助于不久的将来帮助自己回顾。接下来，我会逐步更新博客，将数据结构、操作系统、计算机组成原理和计算机网络课程中的重点，尽量简练地表达出来。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。比如，因为数组具有随机访问的特点，常用的二分查找算法要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。 写作的思路是这样的： 介绍某一数据结构，形式包括：带有个人理解的文字，引用的文章，图形，代码（C、python） 由该结构引发的一些问题 实战例题的解释","text":"这是数据结构篇。 大学毕业之后，我一直想找机会将所学的基础知识总结一下，这样既能够强化记忆，也有助于不久的将来帮助自己回顾。接下来，我会逐步更新博客，将数据结构、操作系统、计算机组成原理和计算机网络课程中的重点，尽量简练地表达出来。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。比如，因为数组具有随机访问的特点，常用的二分查找算法要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。 写作的思路是这样的： 介绍某一数据结构，形式包括：带有个人理解的文字，引用的文章，图形，代码（C、python） 由该结构引发的一些问题 实战例题的解释 0 基本概念0.1 什么是数据结构关于这个问题，我引用两段话 A data structure is a way to store and organize data in a computer, so that it can be used efficiently 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 数据结构包括三方面内容：逻辑结构、存储结构、数据的运算","categories":[{"name":"基础","slug":"基础","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ds","slug":"ds","permalink":"https://yanlwsometing.gitee.io/blog/tags/ds/"}]},{"title":"个人博客搭建（二）","slug":"个人博客搭建（二）","date":"2023-05-13T13:22:16.000Z","updated":"2023-12-15T08:55:47.786Z","comments":true,"path":"2023/05/13/个人博客搭建（二）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/05/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"在学习了搭建个人博客之后，我又动手更换了主题next，本文用于记录这一过程中遇到的问题以及措施。 1. 部署在Gitee的域名配置以我本人的博客域名为例，个人博客部署之后的域名构成为 yanlw.gitee.io&#x2F;blog，在我尝试了多次之后我确定，这其中的可操作性很低。 yanlw.gitee.io是码云的个人空间地址，设置方法为：设置 –&gt; 个人资料 –&gt;个人空间地址 blog是个人在博客仓库设置的路径，设置方法为：仓库 –&gt; 管理 –&gt; 基本信息 注意：这里的仓库名称与路径是不一样的","text":"在学习了搭建个人博客之后，我又动手更换了主题next，本文用于记录这一过程中遇到的问题以及措施。 1. 部署在Gitee的域名配置以我本人的博客域名为例，个人博客部署之后的域名构成为 yanlw.gitee.io&#x2F;blog，在我尝试了多次之后我确定，这其中的可操作性很低。 yanlw.gitee.io是码云的个人空间地址，设置方法为：设置 –&gt; 个人资料 –&gt;个人空间地址 blog是个人在博客仓库设置的路径，设置方法为：仓库 –&gt; 管理 –&gt; 基本信息 注意：这里的仓库名称与路径是不一样的 2. 部署成功之后，只显示html却不加载样式需要配置站点配置文件，即站点根目录下_config.yml,如下：将url: http://example.com 替换为个人的域名 3. 没法显示图片参考Hexo+Typora写文章时图片显示问题 - 掘金 (juejin.cn)，我采用的是相似的方法。关于配置的问题，以及图片文件的问题，可以参考官方文档资源文件夹 | Hexo，这里有很详细的解释和处理措施。 个人总结的措施如下： 在source文件夹中创建images文件，用于存放图片文件 对typora的插入图片进行设置，并且像那位前辈一样，将自动转义图像url以及相应处勾选 在markdown文章头部，添加typora-root-url: ./.. 之后想插入图片，只需要截图-粘贴，那么便存在images文件的对应文件名的文件夹中 注意：这样添加的图片就不能缩放了，因为格式不同了 4. 侧边栏图标不显示next主题采用的图标库为font-awesome，因此可以查看图标库是否有该图标，官网如下 Font Awesome，一套绝佳的图标字体库和CSS框架 (dashgame.com) 之前无法显示的原因在于，我将主题配置文件进行了更改，改回来之后就可以正常显示 5. 文章折叠我个人使用的是在合适的位置添加&lt;!-- more --&gt;,这样可以灵活的决定在何处折叠 6. Hexo 出现 can not read a block mapping entry顶部的 YAML 写错了。 因为 YAML 语法规定必须要在冒号后加空格，所以没有空格的情况下会报错。 参考材料 Hexo next主题博客搭建及美化 - 掘金 (juejin.cn) Hexo主题 —— NexT优化 - 掘金 (juejin.cn) 开始使用 - NexT 使用文档 (iissnan.com) 资源文件夹 | Hexo Hexo+Typora写文章时图片显示问题 - 掘金 (juejin.cn)","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yanlwsometing.gitee.io/blog/tags/hexo/"},{"name":"搭建","slug":"搭建","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E6%90%AD%E5%BB%BA/"},{"name":"问题总结","slug":"问题总结","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"}]},{"title":"个人博客搭建（一）","slug":"个人博客搭建（一）","date":"2023-05-06T10:09:15.000Z","updated":"2023-12-15T09:24:13.632Z","comments":true,"path":"2023/05/06/个人博客搭建（一）/","link":"","permalink":"https://yanlwsometing.gitee.io/blog/2023/05/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"鉴于本人平时需要积累经验的需要，一个用于展示自己日常总结的静态网站是非常好的实践方式。hexo是一个快速简洁的博客框架，其文章格式为markdown，并且其流行的时间较长，遇到问题也能够快速地找到解决方案。Gitee作为中国版的“GitHub”，访问速度快，故可取。 思路： 在本地环境中安装hexo框架（需要node.js环境） 利用hexo初始化博客网站的相关文件（包括js，css） 在gitee创建仓库（需要git环境），将其配置其中","text":"鉴于本人平时需要积累经验的需要，一个用于展示自己日常总结的静态网站是非常好的实践方式。hexo是一个快速简洁的博客框架，其文章格式为markdown，并且其流行的时间较长，遇到问题也能够快速地找到解决方案。Gitee作为中国版的“GitHub”，访问速度快，故可取。 思路： 在本地环境中安装hexo框架（需要node.js环境） 利用hexo初始化博客网站的相关文件（包括js，css） 在gitee创建仓库（需要git环境），将其配置其中 0 环境配置（win10）0.1 Node.js1234567891011121314151617下载并安装：[Node.js (nodejs.org)](https://nodejs.org/en)验证并查看：node -v（node版本）npm -v（node的包管理器npm的版本）配置镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org 再次验证：cnmp -v (镜像cnpm的版本) 注意：npm版本不符合可能会出现镜像配置失败的情况，需要更新npm，系统有提示的！ 0.2 Git123456789下载并安装：[Git - Downloads (git-scm.com)](https://git-scm.com/downloads)配置账号：git config --global user.email &quot;你的gitee账号&quot;git config --global user.name &quot;你的账号名称&quot; 1 安装hexo以及基本配置hexo官网：https://hexo.io/zh-cn/ 在本地新建一个文件夹blog，以此作为自己的个人博客 123456789101112git bash herecnpm install -g hexo-cli # 安装hexohexo -v # 查看hexo版本hexo init # 生成并初始化bloghexo s # 启动本地博客服务https://localhost:4000 # 在浏览器输入该地址便可查看 注意：所有博文均在source文档中，需要时在其中添加即可 每更新source时，可先在本地查看，即 123456789hexo n &quot;文件名&quot; # 生成文档hexo clean # 清理hexo g # 生成hexo s # 启动hexo d # 部署 2 部署gitee仓库事先准备好一个gitee仓库hexo-blog，接着配置_config.yml 123456789#配置_config.yml ----- # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: # address of hexo-blog branch: master----- 上传到hexo-blog仓库 12345cnpm install --save hexo-deployer-git # 在blog目录下安装git部署插件hexo d # 部署到hexo-bloghttps://YourGithubName.gitee.io/ #访问这个地址可以查看博客 注意：在gitee部署个人博客需要启动Gitee Page服务，具体的网址可以在其中看到 3 更换主题很明显，自带的网站主题风格很难满足每个人的需求。官网中提供了许多好看的风格，如yilia 123456789# 下载到本地的文件themesgit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia # 修改_config.yml theme: yilia # 重新生成即可 参考材料1.【手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo】 https://www.bilibili.com/video/BV1Yb411a7ty/?share_source=copy_web&amp;vd_source=6bd197396e40891d0b5805be6f1fe7d7 2.【hexo最简单的入门教程 - 知乎 (zhihu.com)】(https://zhuanlan.zhihu.com/p/492115006)","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yanlwsometing.gitee.io/blog/tags/hexo/"},{"name":"node.js","slug":"node-js","permalink":"https://yanlwsometing.gitee.io/blog/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"https://yanlwsometing.gitee.io/blog/tags/npm/"},{"name":"git","slug":"git","permalink":"https://yanlwsometing.gitee.io/blog/tags/git/"},{"name":"搭建","slug":"搭建","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"IC基础","slug":"IC基础","permalink":"https://yanlwsometing.gitee.io/blog/categories/IC%E5%9F%BA%E7%A1%80/"},{"name":"OCaml","slug":"OCaml","permalink":"https://yanlwsometing.gitee.io/blog/categories/OCaml/"},{"name":"Verilog","slug":"Verilog","permalink":"https://yanlwsometing.gitee.io/blog/categories/Verilog/"},{"name":"Coq","slug":"Coq","permalink":"https://yanlwsometing.gitee.io/blog/categories/Coq/"},{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/categories/Linux/"},{"name":"其他","slug":"其他","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%85%B6%E4%BB%96/"},{"name":"环境配置","slug":"环境配置","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"基础","slug":"基础","permalink":"https://yanlwsometing.gitee.io/blog/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"TCL","slug":"TCL","permalink":"https://yanlwsometing.gitee.io/blog/tags/TCL/"},{"name":"基础电子元器件","slug":"基础电子元器件","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/"},{"name":"ocaml语法","slug":"ocaml语法","permalink":"https://yanlwsometing.gitee.io/blog/tags/ocaml%E8%AF%AD%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"https://yanlwsometing.gitee.io/blog/tags/Linux/"},{"name":"Linux工具","slug":"Linux工具","permalink":"https://yanlwsometing.gitee.io/blog/tags/Linux%E5%B7%A5%E5%85%B7/"},{"name":"网络安全","slug":"网络安全","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文献","slug":"文献","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E6%96%87%E7%8C%AE/"},{"name":"快捷键","slug":"快捷键","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"ocaml安装","slug":"ocaml安装","permalink":"https://yanlwsometing.gitee.io/blog/tags/ocaml%E5%AE%89%E8%A3%85/"},{"name":"VMware","slug":"VMware","permalink":"https://yanlwsometing.gitee.io/blog/tags/VMware/"},{"name":"wsl2","slug":"wsl2","permalink":"https://yanlwsometing.gitee.io/blog/tags/wsl2/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"ds","slug":"ds","permalink":"https://yanlwsometing.gitee.io/blog/tags/ds/"},{"name":"hexo","slug":"hexo","permalink":"https://yanlwsometing.gitee.io/blog/tags/hexo/"},{"name":"搭建","slug":"搭建","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E6%90%AD%E5%BB%BA/"},{"name":"问题总结","slug":"问题总结","permalink":"https://yanlwsometing.gitee.io/blog/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"node.js","slug":"node-js","permalink":"https://yanlwsometing.gitee.io/blog/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"https://yanlwsometing.gitee.io/blog/tags/npm/"},{"name":"git","slug":"git","permalink":"https://yanlwsometing.gitee.io/blog/tags/git/"}]}